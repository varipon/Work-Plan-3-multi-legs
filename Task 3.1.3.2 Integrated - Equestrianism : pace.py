# ================
# SOFTWARE LICENSE
# ================

# The MIT License (MIT)

# Copyright (c) 2021 Yutaka Sawai (Varipon)

# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:

# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.

# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

# ==============================================================
# LICENSE FOR CONTENT PROCEDURALLY GENERATED USING THIS SOFTWARE
# ==============================================================

# All content procedurally generated by this software and its permutations
# are licensed under Creative Commons Attribution By 3.0:

# https://creativecommons.org/licenses/by/3.0/


#!/usr/bin/python

import bpy
from bpy import *

import mathutils
import math
from mathutils import *
from math import *


class Formula:

    def __init__(self, P, A, J, move, part, helicity, start, end):

        global interval
        global frame_start
        global frame_end

        self.interval = interval
        self.frame_start = frame_start
        self.frame_end = frame_end

        # pivot factor
        self.P = P

        # scale factor
        self.A = A 
        
        # joint number
        self.J = J

        # name
        self.move = move

        # element
        self.part = part

        # element helicity
        self.helicity = helicity

        self.start = start
        self.end = end

        # Create armature and object
        self.amt = bpy.data.armatures.new(move + '.' + part + '.' + helicity + '.data')
        self.rig = bpy.data.objects.new(move + '.' + part + '.' + helicity, self.amt)

        # Joints α(n) -> a[n], β(n) -> b[n], γ(n) -> y[n], δ(n) -> o[n]
        self.a = [0 for i in range(4)] # Joint α
        self.b = [0 for i in range(self.J)] # Joint β
        self.y = [0 for i in range(self.J)] # Joint γ
        self.o = [0 for i in range(self.J)] # Joint δ

        # Configuration Movement
        self.configMovement(self.P, self.A, self.J, self.a, self.b, self.y, self.o)

        # Construction Movement
        self.constructMovement(self.J, self.helicity, self.amt, self.rig, self.a, self.b, self.y, self.o)

        # Construction Rotation
        self.configRotation(self.rig, self.interval, self.frame_start, self.frame_end, self.start, self.end)

        # Configuration Linkage
        self.configLink(self.A, self.J, self.helicity, self.rig, self.move, self.part)

        # Construction Linkage
        self.constructLink(self.A, self.J, self.helicity, self.rig, self.move, self.part)


    def configMovement(self, P, A, J, a, b, y, o):

        mat_a = [0 for i in range(4)] # Joint α matrix
        mat_b = [0 for i in range(self.J)] # Joint β matrix
        mat_y = [0 for i in range(self.J)] # Joint γ matrix
        mat_o = [0 for i in range(self.J)] # Joint δ matrix

        a[1] = mathutils.Euler((P, A, 0.0), 'XYZ')
        print ("a1 =", a[1])

        a[2] = mathutils.Euler((A, -A, 0.0), 'XYZ')
        print ("a2 =", a[2])

        b[1] = mathutils.Euler((-A, A, 0.0), 'XYZ')
        print ("b1 =", b[1])

        o[1] = mathutils.Euler((A, A, 0.0), 'XYZ')
        print ("o1 =", o[1])

        B = A * 2 * sqrt (2)
        C = B + (B * sqrt (2))
        D = C * sqrt (2)
        E = C + D

        a[0] = mathutils.Euler((-A - E + (D * 0.5), -A - (D * 0.5), 0.0), 'XYZ')
        print ("a0 =", a[0])
        mat_a[0] = Matrix.Translation(a[0])

        a[3] = mathutils.Euler((0-a[0].x, 0-a[0].y, 0-a[0].z), 'XYZ')
        print ("a3 =", a[3])
        mat_a[3] = Matrix.Translation(a[3]) 

        y[1] = mathutils.Euler((-A, -A, 0.0), 'XYZ')
        print ("y1 =", y[1])
        mat_y[1] = Matrix.Translation(y[1])

### pattern A

        b[2] = mathutils.Euler((a[0].x + E + (A * 2), a[0].y + (A * 2), 0.0), 'XYZ')
        print ("b2 =", b[2])
        mat_b[2] = Matrix.Translation(b[2])

        b[3] = mathutils.Euler((a[0].x + E - (D * 0.5), a[0].y - (A * 2), 0.0), 'XYZ')
        print ("b3 =", b[3])
        mat_b[3] = Matrix.Translation(b[3])
        
        y[2] = mathutils.Euler((a[0].x + E, a[0].y, 0.0), 'XYZ')
        print ("y2 =", y[2])
        mat_y[2] = Matrix.Translation(y[2])

        y[3] = mathutils.Euler((a[0].x + E - (D * 0.5), a[0].y - (D * 0.5), 0.0), 'XYZ')
        print ("y3 =", y[3])
        mat_y[3] = Matrix.Translation(y[3])

        o[2] = mathutils.Euler((a[0].x + E + (A * 2), a[0].y - (A * 2), 0.0), 'XYZ')
        print ("o2 =", o[2])
        mat_o[2] = Matrix.Translation(o[2])
        
        o[3] = mathutils.Euler((a[0].x + E - (D * 0.5) - (A * 2), a[0].y - (D * 0.5) - (A * 2), 0.0), 'XYZ')
        print ("o3 =", o[3])
        mat_o[3] = Matrix.Translation(o[3])

### pattern A end

        org_rot_mat = Matrix.Rotation(math.radians(0), 4, 'Z')

        # define the rotation
        rot_mat = Matrix.Rotation(math.radians(-45), 4, 'Z')   

        for j in range(2, J - 2):

            mat_y[j + 2] = mat_a[0] @ org_rot_mat @ rot_mat @ mat_a[3] @ mat_y[j]

#            obj.matrix_world = mat_y[j + 2]
            # extract components back out of the matrix
            loc, rot, sca = mat_y[j + 2].decompose()
            y[j + 2] = mathutils.Euler(loc, 'XYZ')
            print("y"+str(j + 2)+" = ", y[j + 2], rot, sca)

            mat_b[j + 2] = mat_a[0] @ org_rot_mat @ rot_mat @ mat_a[3] @ mat_b[j]
            
#            obj.matrix_world = mat_b[j + 2]
            # extract components back out of the matrix
            loc, rot, sca = mat_b[j + 2].decompose()
            b[j + 2] = mathutils.Euler(loc, 'XYZ')
            print("b"+str(j + 2)+" = ", b[j + 2], rot, sca)

            mat_o[j + 2] = mat_a[0] @ org_rot_mat @ rot_mat @ mat_a[3] @ mat_o[j]
            
#            obj.matrix_world = mat_o[j + 2]
            # extract components back out of the matrix
            loc, rot, sca = mat_o[j + 2].decompose()
            o[j + 2] = mathutils.Euler(loc, 'XYZ')
            print("o"+str(j + 2)+" = ", o[j + 2], rot, sca)


    def constructMovement(self, J, helicity, amt, rig, a, b, y, o):

        # Linkages
        aa = [[0 for i in range(4)] for j in range(4)] # Link α(i) - α(j)
        ab = [[0 for i in range(4)] for j in range(4)] # Link α(i) - β(j)
        ya = [[0 for i in range(4)] for j in range(4)] # Link γ(i) - α(j)
        ao = [[0 for i in range(4)] for j in range(4)] # Link α(i) - δ(j)
        ob = [[0 for i in range(self.J)] for j in range(self.J)] # Link δ(i) - β(j)
        yy = [[0 for i in range(self.J)] for j in range(self.J)] # Link γ(i) - γ(j)
        by = [[0 for i in range(self.J)] for j in range(self.J)] # Link β(i) - γ(j)
        yo = [[0 for i in range(self.J)] for j in range(self.J)] # Link γ(i) - δ(j)

        rig.location = mathutils.Euler((0.0, 0.0, 0.0), 'XYZ')
        rig.show_in_front = True
        amt.show_names = True
        amt.display_type = 'STICK'
#        amt.display_type = 'BBONE'

        # Link object to scene

        bpy.data.collections['movement'].objects.link(rig)
        bpy.context.view_layer.objects.active = rig
        bpy.context.view_layer.update()

        # Edit
        bpy.ops.object.editmode_toggle()

        # Construction Linkage
        aa[2][1] = amt.edit_bones.new('a2a1')
        aa[2][1].head = a[2]
        aa[2][1].tail = a[1]
        
        ab[1][1] = amt.edit_bones.new('a1b1')
        ab[1][1].head = a[1]
        ab[1][1].tail = b[1]
        ab[1][1].parent = aa[2][1]
 
        by[1][1] = amt.edit_bones.new('b1y1')
        by[1][1].head = b[1]
        by[1][1].tail = y[1]
        by[1][1].parent = ab[1][1]
        by[1][1].use_inherit_rotation = False

        ya[1][2] = amt.edit_bones.new('y1a2')
        ya[1][2].head = y[1]
        ya[1][2].tail = a[2]
        ya[1][2].parent = by[1][1]

        ao[2][1] = amt.edit_bones.new('a2o1')
        ao[2][1].head = a[2]
        ao[2][1].tail = o[1]
        ao[2][1].parent = ya[1][2]

        ob[1][2] = amt.edit_bones.new('o1b2')
        ob[1][2].head = o[1]
        ob[1][2].tail = b[2]
        ob[1][2].parent = ao[2][1]
        
        yy[1][2] = amt.edit_bones.new('y1y2')
        yy[1][2].head = y[1]
        yy[1][2].tail = y[2]
        yy[1][2].parent = by[1][1]

        for j in range(2, J - 1):

            by[j][j] = amt.edit_bones.new('b'+ str(j) + 'y'+ str(j))
            by[j][j].head = b[j]
            by[j][j].tail = y[j]
            by[j][j].parent = ob[j-1][j]

            yo[j][j] = amt.edit_bones.new('y'+ str(j) + 'o'+ str(j))
            yo[j][j].head = y[j]
            yo[j][j].tail = o[j]
            yo[j][j].parent = yy[j-1][j]

            yy[j][j+1] = amt.edit_bones.new('y'+ str(j) + 'y'+ str(j+1))
            yy[j][j+1].head = y[j]
            yy[j][j+1].tail = y[j+1]
            yy[j][j+1].parent = by[j][j]

            if j < (J-2):
                ob[j][j+1] = amt.edit_bones.new('o'+ str(j) + 'b'+ str(j+1))
                ob[j][j+1].head = o[j]
                ob[j][j+1].tail = b[j+1]
                ob[j][j+1].parent = yo[j][j]

        # all bones select

        # Bone constraints. Armature must be in pose mode.
        bpy.ops.object.mode_set(mode='POSE')

        bpy.ops.pose.select_all(action="SELECT")

        # Edit
        bpy.ops.object.editmode_toggle()

        if helicity == 'right':
            bpy.ops.armature.calculate_roll(type='GLOBAL_POS_Z')
        else:
            bpy.ops.armature.calculate_roll(type='GLOBAL_NEG_Z')
 
        # IK constraint
        cns = rig.pose.bones['y1a2'].constraints.new('IK')
        cns.name = 'Ik'
        cns.target = rig
        cns.subtarget = 'a2a1'
        cns.chain_count = 2
        cns.use_stretch = False

        for j in range(2, J - 1):
            cns = rig.pose.bones['b'+str(j) +'y'+str(j)].constraints.new('IK')
            cns.name = 'Ik'
            cns.target = rig
            cns.subtarget = 'y'+str(j)+'o'+str(j)
            cns.iterations = 500
            cns.chain_count = 2
            cns.use_stretch = False

        bpy.ops.object.mode_set(mode='OBJECT')
        

    def configRotation(self, rig, interval, frame_start, frame_end, start, end):

        # Bone constraints. Armature must be in pose mode.
        bpy.ops.object.mode_set(mode='POSE')

        # key insert 
        keyframe_insert_interval = interval

        rig.pose.bones["a1b1"].rotation_mode = 'XYZ'
        rig.pose.bones["a1b1"].rotation_euler.z = math.radians(start) 
        rig.pose.bones["a1b1"].keyframe_insert(data_path="rotation_euler",frame=frame_start)

        rig.pose.bones["a1b1"].rotation_mode = 'XYZ'
        rig.pose.bones["a1b1"].rotation_euler.z = math.radians(end)
        rig.pose.bones["a1b1"].keyframe_insert(data_path="rotation_euler",frame=frame_end)

        for curve in bpy.context.active_object.animation_data.action.fcurves:
            cycles = curve.modifiers.new(type='CYCLES')
            cycles.mode_before = 'REPEAT_OFFSET'
            cycles.mode_after = 'REPEAT_OFFSET'

            for keyframe in curve.keyframe_points:
                keyframe.interpolation = 'LINEAR'

        bpy.ops.object.mode_set(mode='OBJECT')


    def configLink(self, A, J, helicity, rig, move, part):

        bpy.ops.object.mode_set(mode='OBJECT')
    
        Q = (0.18648+0.146446)*A
    #   Z = -Q*2
        Z = 0.0

        obj_joint = bpy.data.objects["joint.gold.000"].copy()
        obj_joint.location = (0.0, 0.0, -Q*3+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "a2a1.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.silver.001"].copy()
        obj_joint.location = (0.0, 0.0, +Q+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "y1a2.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.copper.001"].copy()
        obj_joint.location = (0.0, 0.0, +Q*3+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "a2o1.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.blue.001"].copy()
        obj_joint.location = (0.0, 0.0, -Q*2+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "a1b1.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)


        for n in range(1, J - 1):

            if n <= (J-2):

                # Pattern 2 of by
                obj_joint = bpy.data.objects["joint.green.001"].copy()
                obj_joint.location = (0.0, 0.0, -Q + Q*((n+1) % 2)*4 +Z)
                obj_joint.scale = (A, A, A)
                obj_joint.name = "b"+str(n)+"y"+str(n)+".mesh." + move + '.' + part +'.' + helicity
                bpy.data.collections['link'].objects.link(obj_joint)

                # Pattern 2 of yy
                obj_joint = bpy.data.objects["joint.gold.00"+str(1 + (n+1) % 2)].copy()
                obj_joint.location = (0.0, 0.0, +Q*(1 - (n % 2))*2+Z)
                obj_joint.scale = (A, A, A)
                obj_joint.name = "y"+str(n)+"y"+str(n+1)+".mesh." + move + '.' + part +'.' + helicity
                bpy.data.collections['link'].objects.link(obj_joint)


            if n <= (J-3):

                # Pattern 1 of ob
                obj_joint = bpy.data.objects["joint.blue.001"].copy()
                obj_joint.location = (0.0, 0.0, -Q*2 + Q*(n % 2)*6 +Z)
                obj_joint.scale = (A, A, A)
                obj_joint.name = "o"+str(n)+"b"+str(n+1)+".mesh." + move + '.' + part +'.' + helicity
                bpy.data.collections['link'].objects.link(obj_joint)

                # Pattern 2 of yo
                obj_joint = bpy.data.objects["joint.copper.001"].copy()
                obj_joint.location = (0.0, 0.0, -Q + Q*((n+1) % 2)*4 +Z)
                obj_joint.scale = (A, A, A)
                obj_joint.name = "y"+str(n+1)+"o"+str(n+1)+".mesh." + move + '.' + part +'.' + helicity
                bpy.data.collections['link'].objects.link(obj_joint)


        for ob in data.collections['link'].objects:
            if "mesh" in ob.name:
                ob.select_set(state = True, view_layer = None)

        bpy.ops.object.make_single_user(type='SELECTED_OBJECTS', object=True, obdata=True, material=True, animation=True)
        bpy.context.scene.cursor.location = (0.0, 0.0, 0.0)
        bpy.ops.object.origin_set(type='ORIGIN_CURSOR')


    def constructLink(self, A, J, helicity, rig, move, part):

        # Move and rotate the tip bone in pose mode
        bpy.context.view_layer.objects.active = rig 

        Y = 1.1838*A

        for n in rig.pose.bones:
            if n.name != "o" + str(J-2) + "b" + str(J-1):
                # we can get the object from the pose bone
                obj = n.id_data
                matrix_final = obj.matrix_world @ n.matrix

                # Create armature and object
                lnk = bpy.data.armatures.new(n.name[:len(n.name)]+'.data.' + helicity)
                lnk_rig = bpy.data.objects.new(n.name[:len(n.name)]+'.link.' + helicity, lnk)
                lnk_rig.location = mathutils.Euler((0.0, 0.0, 0.0), 'XYZ')

                # rig.show_in_front = True
                lnk.show_names = True
                lnk.display_type = 'STICK'

                bpy.data.collections['link'].objects.link(lnk_rig)
                bpy.context.view_layer.objects.active = lnk_rig
                bpy.context.view_layer.update()

                # Create bones

                # mode='EDIT'
                bpy.ops.object.editmode_toggle()
    
                link = lnk.edit_bones.new(n.name[:len(n.name)])
                link.head = (0.0, 0.0, 0.0)
                link.tail = (0.0, Y, 0.0)

                link_head = lnk.edit_bones.new('head')
                link_head.head = (0.0, 0.0, 0.1)
                link_head.tail = (0.0, 0.0, 0.0)
                link_head.parent = link
                link_head.use_inherit_scale = False

                link_tail = lnk.edit_bones.new('tail')
                link_tail.head = (0.0, Y, 0.0)
                link_tail.tail = (0.0, Y, -0.1)
                link_tail.parent = link
                link_tail.use_inherit_scale = False

                bpy.ops.object.mode_set(mode='OBJECT')

                ob = bpy.data.objects[n.name[:len(n.name)]+'.mesh.' + move + '.' + part +'.' + helicity]
                ob.location = mathutils.Euler((0.0, 0.0, 0.0), 'XYZ')
    
                # Give mesh object an armature modifier, using vertex groups but
                # not envelopes
                mod = ob.modifiers.new('MyRigModif', 'ARMATURE')
                mod.object = lnk_rig
                mod.use_bone_envelopes = False
                mod.use_vertex_groups = True

                # Bone constraints. Armature must be in pose mode.
                bpy.ops.object.mode_set(mode='POSE')
 
                # Copy rotation constraints Base -> Tip
                pBase = lnk_rig.pose.bones[n.name[:len(n.name)]]
                cns = pBase.constraints.new('COPY_LOCATION')
                cns.name = 'Copy_Location'
                cns.target = rig
                cns.subtarget = n.name[:len(n.name)]
                cns.owner_space = 'WORLD'
                cns.target_space = 'WORLD'

                # Copy rotation constraints Base -> Tip
                pBase = lnk_rig.pose.bones[n.name[:len(n.name)]]
                cns = pBase.constraints.new('COPY_ROTATION')
                cns.name = 'Copy_Rotation'
                cns.target = rig
                cns.subtarget = n.name[:len(n.name)]
                cns.owner_space = 'WORLD'
                cns.target_space = 'WORLD'

                # StretchTo constraint Mid -> Tip with influence 0.5
                cns1 = pBase.constraints.new('STRETCH_TO')
                cns1.name = 'Stretch'
                cns1.target = rig
                cns1.subtarget = n.name[:len(n.name)]
                cns1.head_tail = 1
                cns1.rest_length = Y
                cns1.influence = 1
                cns1.keep_axis = 'PLANE_Z'
                cns1.volume = 'NO_VOLUME'

                bpy.ops.object.mode_set(mode='OBJECT')


class Costa(Formula):

    J = 4 #joint number

    # Overriding
    def __init__(self, P, A, move, part, helicity, start, end, 
        disciple_loc, disciple_rot, disciple, disciple2):

        global interval
        global frame_start
        global frame_end

        self.interval = interval
        self.frame_start = frame_start
        self.frame_end = frame_end

        # pivot factor
        self.P = P

        # scale factor
        self.A = A 

        # name
        self.move = move

        # element
        self.part = part

        # element helicity
        self.helicity = helicity

        self.start = start
        self.end = end

        # disciple position
        self.disciple_loc = disciple_loc
        self.disciple_rot = disciple_rot

        # disciple
        self.disciple = disciple
        self.disciple2 = disciple2

        # Create armature and object
        self.amt = bpy.data.armatures.new(move + '.' + part + '.' + helicity + '.data')
        self.rig = bpy.data.objects.new(move + '.' + part + '.' + helicity, self.amt)

        # Joints
        self.a = [0 for i in range(self.J)] # Joint α
        self.b = [0 for i in range(self.J)] # Joint β
        self.y = [0 for i in range(self.J)] # Joint γ
        self.o = [0 for i in range(self.J)] # Joint δ

        # Configuration Movement
        self.configMovement(self.P, self.A, self.J, self.a, self.b, self.y, self.o)

        # Construction Movement
        self.constructMovement(self.J, self.helicity, self.amt, self.rig, self.a, self.b, self.y, self.o)

        # Parent set disciple to master       
        self.setParent(self.helicity, self.move, self.rig, 
            self.disciple_loc, self.disciple_rot, self.disciple, self.disciple2)

        # Construction Rotation
        self.configRotation(self.rig, self.interval, self.frame_start, self.frame_end, self.start, self.end)

        # Configuration Linkage
        self.configLink(1.25*self.A*0.4, self.J, self.helicity, self.rig, self.move, self.part)

        # Construction Linkage
        self.constructLink(1.25*self.A*0.4, self.J, self.helicity, self.rig, self.move, self.part)

    # Overriding Configuration Movement
    def configMovement(self, P, A, J, a, b, y, o):

        a[1] = mathutils.Euler((P, A, 0.0), 'XYZ')
        print ("a1 =", a[1])

        a[2] = mathutils.Euler((A, -A, 0.0), 'XYZ')
        print ("a2 =", a[2])

        b[1] = mathutils.Euler((-A, A, 0.0), 'XYZ')
        print ("b1 =", b[1])

        B = A * 2 * sqrt (2)
        C = B + (B * sqrt (2))
        D = C * sqrt (2)
        E = C + D

        y[1] = mathutils.Euler((-A, -A, 0.0), 'XYZ')
        print ("y1 =", y[1])
        
        y[2] = mathutils.Euler((-A, (-1.72423/1.28082)*A, 0.0), 'XYZ')
        print ("y2 =", y[2])

        o[1] = mathutils.Euler(((-10.6563/1.28082)*A, -A, 0.0), 'XYZ')
        print ("o1 =", o[1])
        
        b[2] = mathutils.Euler(((-10.6563/1.28082)*A, (-1.72423/1.28082)*A, 0.0), 'XYZ')
        print ("b2 =", b[2])

        o[2] = mathutils.Euler((-A, (-1.97185/1.28082)*A, 0.0), 'XYZ')
        print ("o2 =", o[2])

    def constructMovement(self, J, helicity, amt, rig, a, b, y, o):

        # Linkages
        aa = [[0 for i in range(4)] for j in range(4)] # Link α(i) - α(j)
        ab = [[0 for i in range(4)] for j in range(4)] # Link α(i) - β(j)
        ya = [[0 for i in range(4)] for j in range(4)] # Link γ(i) - α(j)
#        ao = [[0 for i in range(4)] for j in range(4)] # Link α(i) - δ(j)
        ob = [[0 for i in range(self.J)] for j in range(self.J)] # Link δ(i) - β(j)
        yy = [[0 for i in range(self.J)] for j in range(self.J)] # Link γ(i) - γ(j)
        by = [[0 for i in range(self.J)] for j in range(self.J)] # Link β(i) - γ(j)
        yo = [[0 for i in range(self.J)] for j in range(self.J)] # Link γ(i) - δ(j)

        rig.location = mathutils.Euler((0.0, 0.0, 0.0), 'XYZ')
        rig.show_in_front = True
        amt.show_names = True
        amt.display_type = 'STICK'
#        amt.display_type = 'BBONE'

        # Link object to scene

        bpy.data.collections['movement'].objects.link(rig)
        bpy.context.view_layer.objects.active = rig
        bpy.context.view_layer.update()

        # Edit
        bpy.ops.object.editmode_toggle()

        # Construction Linkage
        aa[2][1] = amt.edit_bones.new('a2a1')
        aa[2][1].head = a[2]
        aa[2][1].tail = a[1]
        
        ab[1][1] = amt.edit_bones.new('a1b1')
        ab[1][1].head = a[1]
        ab[1][1].tail = b[1]
        ab[1][1].parent = aa[2][1]
 
        by[1][1] = amt.edit_bones.new('b1y1')
        by[1][1].head = b[1]
        by[1][1].tail = y[1]
        by[1][1].parent = ab[1][1]
        by[1][1].use_inherit_rotation = False

        ya[1][2] = amt.edit_bones.new('y1a2')
        ya[1][2].head = y[1]
        ya[1][2].tail = a[2]
        ya[1][2].parent = by[1][1]

        yo[1][1] = amt.edit_bones.new('y1o1')
        yo[1][1].head = y[1]
        yo[1][1].tail = o[1]
        yo[1][1].parent = ya[1][2]

        ob[1][2] = amt.edit_bones.new('o1b2')
        ob[1][2].head = o[1]
        ob[1][2].tail = b[2]
        ob[1][2].parent = yo[1][1]
        
        yy[1][2] = amt.edit_bones.new('y1y2')
        yy[1][2].head = y[1]
        yy[1][2].tail = y[2]
        yy[1][2].parent = by[1][1]

        by[2][2] = amt.edit_bones.new('b'+ str(2) + 'y'+ str(2))
        by[2][2].head = b[2]
        by[2][2].tail = y[2]
        by[2][2].parent = ob[1][2]

        yo[2][2] = amt.edit_bones.new('y'+ str(2) + 'o'+ str(2))
        yo[2][2].head = y[2]
        yo[2][2].tail = o[2]
        yo[2][2].parent = yy[1][2]

        # all bones select

        # Bone constraints. Armature must be in pose mode.
        bpy.ops.object.mode_set(mode='POSE')

        bpy.ops.pose.select_all(action="SELECT")

        # Edit
        bpy.ops.object.editmode_toggle()

        if helicity == 'right':
            bpy.ops.armature.calculate_roll(type='GLOBAL_POS_Z')
        else:
            bpy.ops.armature.calculate_roll(type='GLOBAL_NEG_Z')
 
        # IK constraint
        cns = rig.pose.bones['y1a2'].constraints.new('IK')
        cns.name = 'Ik'
        cns.target = rig
        cns.subtarget = 'a2a1'
        cns.chain_count = 2
        cns.use_stretch = False

        cns = rig.pose.bones['b2y2'].constraints.new('IK')
        cns.name = 'Ik'
        cns.target = rig
        cns.subtarget = 'y2o2'
        cns.iterations = 500
        cns.chain_count = 2
        cns.use_stretch = False

        bpy.ops.object.mode_set(mode='OBJECT')

    # Parent set disciple to master        
    def setParent(self, helicity, move, rig, 
        disciple_loc, disciple_rot, disciple, disciple2):

        bpy.ops.object.mode_set(mode='OBJECT')

        bpy.context.scene.frame_current = 0

        bpy.ops.object.select_all(action='DESELECT')
        rig.select_set(state=True)
        bpy.context.view_layer.objects.active = rig

        bpy.ops.object.editmode_toggle()

        parent_bone = 'y1o1' # choose the bone name which you want to be the parent

        rig.data.edit_bones.active = rig.data.edit_bones[parent_bone]

        bpy.ops.object.mode_set(mode='OBJECT')

        bpy.ops.object.select_all(action='DESELECT') #deselect all objects

        disciple.rig.select_set(state=True)
        disciple2.rig.select_set(state=True)

        rig.select_set(state=True)
        bpy.context.view_layer.objects.active = rig    #the active object will be the parent of all selected object

        bpy.ops.object.parent_set(type='BONE', keep_transform=True)
                
        bpy.ops.object.select_all(action='DESELECT') #deselect all objects

        # disciple position
        disciple.rig.location.x += disciple_loc[0]
        disciple.rig.location.y += disciple_loc[1]
        disciple.rig.location.z += disciple_loc[2]

        disciple.rig.rotation_euler = disciple_rot

        # disciple2 position
        disciple2.rig.location.x += disciple_loc[0]
        disciple2.rig.location.y += disciple_loc[1]
        disciple2.rig.location.z += disciple_loc[2]

        disciple2.rig.rotation_euler = disciple_rot

    def configLink(self, A, J, helicity, rig, move, part):

        bpy.ops.object.mode_set(mode='OBJECT')
    
        Q = (0.18648+0.146446)*A
    #   Z = -Q*2
        Z = 0.0

        obj_joint = bpy.data.objects["joint.gold.000"].copy()
        obj_joint.location = (0.0, 0.0, -Q*3+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "a2a1.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.silver.001"].copy()
        obj_joint.location = (0.0, 0.0, +Q+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "y1a2.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.copper.y1o1"].copy()
        obj_joint.location = (0.0, 0.0, +Q*3+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "y1o1.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.blue.001"].copy()
        obj_joint.location = (0.0, 0.0, -Q*2+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "a1b1.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        n = 1

        # Pattern 2 of by
        obj_joint = bpy.data.objects["joint.green.001"].copy()
        obj_joint.location = (0.0, 0.0, -Q + Q*((n+1) % 2)*4 +Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "b"+str(n)+"y"+str(n)+".mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        # Pattern 2 of yy
        obj_joint = bpy.data.objects["joint.gold.00"+str(1 + (n+1) % 2)].copy()
        obj_joint.location = (0.0, 0.0, +Q*(1 - (n % 2))*2+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "y"+str(n)+"y"+str(n+1)+".mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        # Pattern 1 of ob
        obj_joint = bpy.data.objects["joint.blue.001"].copy()
        obj_joint.location = (0.0, 0.0, -Q*2 + Q*(n % 2)*6 +Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "o"+str(n)+"b"+str(n+1)+".mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        # Pattern 2 of yo
        obj_joint = bpy.data.objects["joint.copper.001"].copy()
        obj_joint.location = (0.0, 0.0, -Q + Q*((n+1) % 2)*4 +Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "y"+str(n+1)+"o"+str(n+1)+".mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        n = 2
        
        # Pattern 2 of by
        obj_joint = bpy.data.objects["joint.green.b2y2"].copy()
        obj_joint.location = (0.0, 0.0, -Q + Q*((n+1) % 2)*4 +Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "b"+str(n)+"y"+str(n)+".mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        for ob in data.collections['link'].objects:
            if "mesh" in ob.name:
                ob.select_set(state = True, view_layer = None)

        bpy.ops.object.make_single_user(type='SELECTED_OBJECTS', object=True, obdata=True, material=True, animation=True)
        bpy.context.scene.cursor.location = (0.0, 0.0, 0.0)
        bpy.ops.object.origin_set(type='ORIGIN_CURSOR')
        

class Spine(Formula):

    J = 7 #joint number

    # Overriding
    def __init__(self, P, A, move, part, helicity, start, end,
            disciple_loc, disciple_rot, disciple,
            disciple2_loc, disciple2_rot, disciple2, disciple3):

        global interval
        global frame_start
        global frame_end

        self.interval = interval
        self.frame_start = frame_start
        self.frame_end = frame_end

        # pivot factor
        self.P = P

        # scale factor
        self.A = A 

        # name
        self.move = move

        # element
        self.part = part

        # element helicity
        self.helicity = helicity

        self.start = start
        self.end = end

        # disciple position
        self.disciple_loc = disciple_loc
        self.disciple_rot = disciple_rot

        # disciple position
        self.disciple2_loc = disciple2_loc
        self.disciple2_rot = disciple2_rot

        # disciple
        self.disciple = disciple
        self.disciple2 = disciple2
        self.disciple3 = disciple3

        # Create armature and object
        self.amt = bpy.data.armatures.new(move + '.' + part + '.' + helicity + '.data')
        self.rig = bpy.data.objects.new(move + '.' + part + '.' + helicity, self.amt)

        # Joints
        self.a = [0 for i in range(4)] # Joint α
        self.b = [0 for i in range(self.J)] # Joint β
        self.y = [0 for i in range(self.J)] # Joint γ
        self.o = [0 for i in range(self.J)] # Joint δ

        # Configuration Movement
        self.configMovement(self.P, self.A, self.J, self.a, self.b, self.y, self.o)

        # Construction Movement
        self.constructMovement(self.J, self.helicity, self.amt, self.rig, self.a, self.b, self.y, self.o)

        # Parent set disciple to master        
        self.setParent(self.helicity, self.move, self.rig, 
            self.disciple_loc, self.disciple_rot, self.disciple, 
            self.disciple2_loc, self.disciple2_rot, self.disciple2, self.disciple3)

        # Construction Rotation
        self.configRotation(self.rig, self.interval, self.frame_start, self.frame_end, self.start, self.end)

        # Configuration Linkage
        self.configLink(self.A*0.5, self.J, self.helicity, self.rig, self.move, self.part)

        # Construction Linkage
        self.constructLink(self.A*0.5, self.J, self.helicity, self.rig, self.move, self.part)

    # Overriding Configuration Movement
    def configMovement(self, P, A, J, a, b, y, o):

        a[1] = mathutils.Euler((P, A, 0.0), 'XYZ')
        print ("a1 =", a[1])

        a[2] = mathutils.Euler((A, -A, 0.0), 'XYZ')
        print ("a2 =", a[2])

        b[1] = mathutils.Euler((-A, A, 0.0), 'XYZ')
        print ("b1 =", b[1])

        o[1] = mathutils.Euler((A, A, 0.0), 'XYZ')
        print ("o1 =", o[1])

        B = A * 2 * sqrt (2)
        C = B + (B * sqrt (2))
        D = C * sqrt (2)
        E = C + D
        
        y[1] = mathutils.Euler((-A, -A, 0.0), 'XYZ')
        print ("y1 =", y[1])

        b[2] = mathutils.Euler(((10.0046/1.71652)*A, (-6.57156/1.71652)*A, 0.0), 'XYZ')
        print ("b2 =", b[2])

        b[3] = mathutils.Euler(((10.0046/1.71652)*A, (-18.2927/1.71652)*A, 0.0), 'XYZ')
        print ("b3 =", b[3])

        b[4] = mathutils.Euler(((3.13855/1.71652)*A, (-13.4376/1.71652)*A, 0.0), 'XYZ')
        print ("b4 =", b[4])

        y[2] = mathutils.Euler(((6.57156/1.71652)*A, (-10.0046/1.71652)*A, 0.0), 'XYZ')
        print ("y2 =", y[2])

        y[3] = mathutils.Euler(((14.8597/1.71652)*A, (-18.2927/1.71652)*A, 0.0), 'XYZ')
        print ("y3 =", y[3])

        o[2] = b[2]
        print ("o2 =", o[2])

        o[3] = mathutils.Euler(((14.8597/1.71652)*A, (-13.4376/1.71652)*A, 0.0), 'XYZ')
        print ("o3 =", o[3])
                
        y[4] = y[2]
        print ("y4 =", y[4])
        
        o[4] = b[4]
        print ("o4 =", o[4])

        b[5] = mathutils.Euler(((-5.14955/1.71652)*A, (-5.14955/1.71652)*A, 0.0), 'XYZ')
        print ("b5 =", b[5])

        y[5] = y[1]
        print ("y5 =", y[5])

        o[5] = b[5]
        
        y[6] = mathutils.Euler(((-10.0046/1.71652)*A, (6.57156/1.71652)*A, 0.0), 'XYZ')
        print ("y6 =", y[6])

    # Parent set disciple to master
    def setParent(self, helicity, move, rig,
        disciple_loc, disciple_rot, disciple,
        disciple2_loc, disciple2_rot, disciple2, disciple3):

        bpy.ops.object.mode_set(mode='OBJECT')

        bpy.context.scene.frame_current = 0

        bpy.ops.object.select_all(action='DESELECT')
        rig.select_set(state=True)
        bpy.context.view_layer.objects.active = rig

        bpy.ops.object.editmode_toggle()

        parent_bone = 'y5y6' # choose the bone name which you want to be the parent

        rig.data.edit_bones.active = rig.data.edit_bones[parent_bone]

        bpy.ops.object.mode_set(mode='OBJECT')

        bpy.ops.object.select_all(action='DESELECT') #deselect all objects

        disciple.rig.select_set(state=True)

        rig.select_set(state=True)
        bpy.context.view_layer.objects.active = rig    #the active object will be the parent of all selected object

        bpy.ops.object.parent_set(type='BONE', keep_transform=True)
        
        bpy.ops.object.select_all(action='DESELECT') #deselect all objects
        rig.select_set(state=True)
        bpy.context.view_layer.objects.active = rig

        bpy.ops.object.editmode_toggle()

        parent_bone = 'y3y4' # choose the bone name which you want to be the parent

        rig.data.edit_bones.active = rig.data.edit_bones[parent_bone]

        bpy.ops.object.mode_set(mode='OBJECT')

        bpy.ops.object.select_all(action='DESELECT') #deselect all objects

        disciple2.rig.select_set(state=True)
        disciple3.rig.select_set(state=True)

        rig.select_set(state=True)
        bpy.context.view_layer.objects.active = rig    #the active object will be the parent of all selected object

        bpy.ops.object.parent_set(type='BONE', keep_transform=True)
        
        bpy.ops.object.select_all(action='DESELECT') #deselect all objects

        # disciple position
        disciple.rig.location.x += disciple_loc[0]
        disciple.rig.location.y += disciple_loc[1]
        disciple.rig.location.z += disciple_loc[2]

        disciple.rig.rotation_euler = disciple_rot

        # disciple2 position
        disciple2.rig.location.x += disciple2_loc[0]
        disciple2.rig.location.y += disciple2_loc[1]
        disciple2.rig.location.z += disciple2_loc[2]

        disciple2.rig.rotation_euler = disciple2_rot

        # disciple3 position
        disciple3.rig.location.x += disciple2_loc[0]
        disciple3.rig.location.y += disciple2_loc[1]
        disciple3.rig.location.z += disciple2_loc[2]

        disciple3.rig.rotation_euler = disciple2_rot 

    def configLink(self, A, J, helicity, rig, move, part):

        bpy.ops.object.mode_set(mode='OBJECT')
    
        Q = (0.18648+0.146446)*A
    #   Z = -Q*2
        Z = 0.0

        obj_joint = bpy.data.objects["joint.gold.spine.a2a1"].copy()
        obj_joint.location = (0.0, 0.0, -Q*3+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "a2a1.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.silver.001"].copy()
        obj_joint.location = (0.0, 0.0, +Q+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "y1a2.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.copper.001"].copy()
        obj_joint.location = (0.0, 0.0, +Q*3+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "a2o1.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.blue.001"].copy()
        obj_joint.location = (0.0, 0.0, -Q*2+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "a1b1.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)


        for n in range(1, J - 1):
            
            if n >= (3):
                N=-Q*5
            else:
                N=-Q*0

            if n <= (J-2):

                # Pattern 2 of by
                obj_joint = bpy.data.objects["joint.green.001"].copy()
                obj_joint.location = (0.0, 0.0, N-Q + Q*((n+1) % 2)*4 +Z)
                obj_joint.scale = (A, A, A)
                obj_joint.name = "b"+str(n)+"y"+str(n)+".mesh." + move + '.' + part +'.' + helicity
                bpy.data.collections['link'].objects.link(obj_joint)

            if n <= (J-3):

                # Pattern 2 of yy
                if n == (2):
                    obj_joint = bpy.data.objects["joint.gold.spine.y2y3"].copy()
                else:
                    obj_joint = bpy.data.objects["joint.gold.00"+str(1 + (n+1) % 2)].copy()

                obj_joint.location = (0.0, 0.0, N+Q*(1 - (n % 2))*2+Z)
                obj_joint.scale = (A, A, A)
                obj_joint.name = "y"+str(n)+"y"+str(n+1)+".mesh." + move + '.' + part +'.' + helicity
                bpy.data.collections['link'].objects.link(obj_joint)

                # Pattern 1 of ob
                if n == (2):
                    obj_joint = bpy.data.objects["joint.blue.spine.o2b3"].copy()
                else:
                    obj_joint = bpy.data.objects["joint.blue.001"].copy()
                    
                obj_joint.location = (0.0, 0.0, N-Q*2 + Q*(n % 2)*6 +Z)
                obj_joint.scale = (A, A, A)
                obj_joint.name = "o"+str(n)+"b"+str(n+1)+".mesh." + move + '.' + part +'.' + helicity
                bpy.data.collections['link'].objects.link(obj_joint)

                # Pattern 2 of yo
                if n == (2):
                    obj_joint = bpy.data.objects["joint.copper.spine.y3o3"].copy()
                else:
                    obj_joint = bpy.data.objects["joint.copper.001"].copy()

                obj_joint.location = (0.0, 0.0, N-Q + Q*((n+1) % 2)*4 +Z)
                obj_joint.scale = (A, A, A)
                obj_joint.name = "y"+str(n+1)+"o"+str(n+1)+".mesh." + move + '.' + part +'.' + helicity
                bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.gold.spine.y5y6"].copy()
        obj_joint.location = (0.0, 0.0, N+Q*(1 - (n % 2))*2+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "y5y6.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        for ob in data.collections['link'].objects:
            if "mesh" in ob.name:
                ob.select_set(state = True, view_layer = None)

        bpy.ops.object.make_single_user(type='SELECTED_OBJECTS', object=True, obdata=True, material=True, animation=True)
        bpy.context.scene.cursor.location = (0.0, 0.0, 0.0)
        bpy.ops.object.origin_set(type='ORIGIN_CURSOR')


class LowerForelimb(Formula):

    J = 6 #joint number

    # Overriding
    def __init__(self, P, A, move, part, helicity, start, end):

        global interval
        global frame_start
        global frame_end

        self.interval = interval
        self.frame_start = frame_start
        self.frame_end = frame_end

        # pivot factor
        self.P = P

        # scale factor
        self.A = A 

        # name
        self.move = move

        # element
        self.part = part

        # element helicity
        self.helicity = helicity

        self.start = start
        self.end = end

        # Create armature and object
        self.amt = bpy.data.armatures.new(move + '.' + part + '.' + helicity + '.data')
        self.rig = bpy.data.objects.new(move + '.' + part + '.' + helicity, self.amt)

        # Joints
        self.a = [0 for i in range(4)] # Joint α
        self.b = [0 for i in range(self.J)] # Joint β
        self.y = [0 for i in range(self.J)] # Joint γ
        self.o = [0 for i in range(self.J)] # Joint δ

        # Configuration Movement
        self.configMovement(self.P, self.A, self.J, self.a, self.b, self.y, self.o)

        # Construction Movement
        self.constructMovement(self.J, self.helicity, self.amt, self.rig, self.a, self.b, self.y, self.o)

        # Construction Rotation
        self.configRotation(self.rig, self.interval, self.frame_start, self.frame_end, self.start, self.end)

        # Configuration Linkage
        self.configLink(1.8*self.A, self.J, self.helicity, self.rig, self.move, self.part)

        # Construction Linkage
        self.constructLink(1.8*self.A, self.J, self.helicity, self.rig, self.move, self.part)

    # Overriding Configuration Movement
    def configMovement(self, P, A, J, a, b, y, o):

        a[1] = mathutils.Euler((P, A, 0.0), 'XYZ')
        print ("a1 =", a[1])

        a[2] = mathutils.Euler((A, -A, 0.0), 'XYZ')
        print ("a2 =", a[2])

        b[1] = mathutils.Euler((-A, A, 0.0), 'XYZ')
        print ("b1 =", b[1])

        o[1] = mathutils.Euler((A, A, 0.0), 'XYZ')
        print ("o1 =", o[1])

        B = A * 2 * sqrt (2)
        C = B + (B * sqrt (2))
        D = C * sqrt (2)
        E = C + D

        y[1] = mathutils.Euler((-A, -A, 0.0), 'XYZ')
        print ("y1 =", y[1])
        
        b[2] = mathutils.Euler(((1.05/0.35)*A, A, 0.0), 'XYZ')
        print ("b2 =", b[2])

        b[3] = mathutils.Euler(((2.2642/0.35)*A, (-4.97125/0.35)*A, 0.0), 'XYZ')
        print ("b3 =", b[3])

        b[4] = mathutils.Euler(((6.42315/0.35)*A, (-5.57265/0.35)*A, 0.0), 'XYZ')
        print ("b4 =", b[4])

        y[2] = mathutils.Euler((A, -A, 0.0), 'XYZ')
        print ("y2 =", y[2])

        y[3] = mathutils.Euler(((4.97125/0.35)*A, (-4.97125/0.35)*A, 0.0), 'XYZ')
        print ("y3 =", y[3])

        y[4] = mathutils.Euler(((5.9979/0.35)*A, (-5.9979/0.35)*A, 0.0), 'XYZ')
        print ("y4 =", y[4])

        y[5] = mathutils.Euler(((7.653072/0.35)*A, (-7.653072/0.35)*A, 0.0), 'XYZ')
        print ("y5 =", y[5])

        o[2] = mathutils.Euler(((2.2642/0.35)*A, (1.56419/0.35)*A, 0.0), 'XYZ')
        print ("o2 =", o[2])

        o[3] = mathutils.Euler(((4.97125/0.35)*A, (-5.57265/0.35)*A, 0.0), 'XYZ')
        print ("o3 =", o[3])
        
        o[4] = mathutils.Euler(((6.8484/0.35)*A, (-5.9979/0.35)*A, 0.0), 'XYZ')
        print ("o4 =", o[4])

    def configLink(self, A, J, helicity, rig, move, part):

        bpy.ops.object.mode_set(mode='OBJECT')
    
        Q = (0.18648+0.146446)*A
    #   Z = -Q*2
        Z = 0.0

        if part == 'right-lowerforelimb':
            obj_joint = bpy.data.objects["joint.gold.a2a1.lowerforelimb-right"].copy()
        else:
            obj_joint = bpy.data.objects["joint.gold.a2a1.lowerforelimb-left"].copy()
        
        obj_joint.location = (0.0, 0.0, -Q*3+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "a2a1.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.silver.001"].copy()
        obj_joint.location = (0.0, 0.0, +Q+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "y1a2.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.copper.001"].copy()
        obj_joint.location = (0.0, 0.0, +Q*3+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "a2o1.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.blue.001"].copy()
        obj_joint.location = (0.0, 0.0, -Q*2+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "a1b1.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)


        for n in range(1, J - 1):

            if n <= (J-2):

                # Pattern 2 of by
                obj_joint = bpy.data.objects["joint.green.001"].copy()
                obj_joint.location = (0.0, 0.0, -Q + Q*((n+1) % 2)*4 +Z)
                obj_joint.scale = (A, A, A)
                obj_joint.name = "b"+str(n)+"y"+str(n)+".mesh." + move + '.' + part +'.' + helicity
                bpy.data.collections['link'].objects.link(obj_joint)

                # Pattern 2 of yy
                obj_joint = bpy.data.objects["joint.gold.00"+str(1 + (n+1) % 2)].copy()
                obj_joint.location = (0.0, 0.0, +Q*(1 - (n % 2))*2+Z)
                obj_joint.scale = (A, A, A)
                obj_joint.name = "y"+str(n)+"y"+str(n+1)+".mesh." + move + '.' + part +'.' + helicity
                bpy.data.collections['link'].objects.link(obj_joint)


            if n <= (J-3):

                # Pattern 1 of ob
                obj_joint = bpy.data.objects["joint.blue.001"].copy()
                obj_joint.location = (0.0, 0.0, -Q*2 + Q*(n % 2)*6 +Z)
                obj_joint.scale = (A, A, A)
                obj_joint.name = "o"+str(n)+"b"+str(n+1)+".mesh." + move + '.' + part +'.' + helicity
                bpy.data.collections['link'].objects.link(obj_joint)

                # Pattern 2 of yo
                obj_joint = bpy.data.objects["joint.copper.001"].copy()
                obj_joint.location = (0.0, 0.0, -Q + Q*((n+1) % 2)*4 +Z)
                obj_joint.scale = (A, A, A)
                obj_joint.name = "y"+str(n+1)+"o"+str(n+1)+".mesh." + move + '.' + part +'.' + helicity
                bpy.data.collections['link'].objects.link(obj_joint)


        for ob in data.collections['link'].objects:
            if "mesh" in ob.name:
                ob.select_set(state = True, view_layer = None)

        bpy.ops.object.make_single_user(type='SELECTED_OBJECTS', object=True, obdata=True, material=True, animation=True)
        bpy.context.scene.cursor.location = (0.0, 0.0, 0.0)
        bpy.ops.object.origin_set(type='ORIGIN_CURSOR')


class UpperForelimb(Formula):

    J = 5 #joint number

    # Overriding
    def __init__(self, P, A, move, part, helicity, start, end, disciple_loc, disciple_rot, disciple):

        global interval
        global frame_start
        global frame_end

        self.interval = interval
        self.frame_start = frame_start
        self.frame_end = frame_end

        # pivot factor
        self.P = P

        # scale factor
        self.A = A 

        # name
        self.move = move

        # element
        self.part = part

        # element helicity
        self.helicity = helicity

        self.start = start
        self.end = end

        # disciple position
        self.disciple_loc = disciple_loc
        self.disciple_rot = disciple_rot

        # disciple
        self.disciple = disciple

        # Create armature and object
        self.amt = bpy.data.armatures.new(move + '.' + part + '.' + helicity + '.data')
        self.rig = bpy.data.objects.new(move + '.' + part + '.' + helicity, self.amt)

        # Joints
        self.a = [0 for i in range(4)] # Joint α
        self.b = [0 for i in range(self.J)] # Joint β
        self.y = [0 for i in range(self.J)] # Joint γ
        self.o = [0 for i in range(self.J)] # Joint δ

        # Configuration Movement
        self.configMovement(self.P, self.A, self.J, self.a, self.b, self.y, self.o)

        # Construction Movement
        self.constructMovement(self.J, self.helicity, self.amt, self.rig, self.a, self.b, self.y, self.o)

        # Parent set disciple to master       
        self.setParent(self.helicity, self.move, self.rig, self.disciple_loc, self.disciple_rot, self.disciple)

        # Construction Rotation
        self.configRotation(self.rig, self.interval, self.frame_start, self.frame_end, self.start, self.end)

        # Configuration Linkage
        self.configLink(1.25*self.A, self.J, self.helicity, self.rig, self.move, self.part)

        # Construction Linkage
        self.constructLink(1.25*self.A, self.J, self.helicity, self.rig, self.move, self.part)

    # Overriding Configuration Movement
    def configMovement(self, P, A, J, a, b, y, o):

        a[1] = mathutils.Euler((P, A, 0.0), 'XYZ')
        print ("a1 =", a[1])

        a[2] = mathutils.Euler((A, -A, 0.0), 'XYZ')
        print ("a2 =", a[2])

        b[1] = mathutils.Euler((-A, A, 0.0), 'XYZ')
        print ("b1 =", b[1])

        o[1] = mathutils.Euler((A, A, 0.0), 'XYZ')
        print ("o1 =", o[1])

        B = A * 2 * sqrt (2)
        C = B + (B * sqrt (2))
        D = C * sqrt (2)
        E = C + D

        y[1] = mathutils.Euler((-A, -A, 0.0), 'XYZ')
        print ("y1 =", y[1])
        
        b[2] = mathutils.Euler(((9.4/0.6)*A, (-8.2/0.6)*A, 0.0), 'XYZ')
        print ("b2 =", b[2])

        b[3] = mathutils.Euler(((7.399085/0.6)*A, (-19.717056/0.6)*A, 0.0), 'XYZ')
        print ("b3 =", b[3])

        y[2] = mathutils.Euler(((8.2/0.6)*A, (-9.4/0.6)*A, 0.0), 'XYZ')
        print ("y2 =", y[2])

        y[3] = mathutils.Euler(((9.08969/0.6)*A, (-19.569149/0.6)*A, 0.0), 'XYZ')
        print ("y3 =", y[3])

        y[4] = mathutils.Euler(((9.2376/0.6)*A, (-21.259787/0.6)*A, 0.0), 'XYZ')
        print ("y4 =", y[4])

        o[2] = mathutils.Euler(((6.509395/0.6)*A, (-9.547907/0.6)*A, 0.0), 'XYZ')
        print ("o2 =", o[2])

        o[3] = mathutils.Euler(((10.38971/0.6)*A, (-20.659994/0.6)*A, 0.0), 'XYZ')
        print ("o3 =", o[3])

    # Parent set disciple to master        
    def setParent(self, helicity, move, rig, disciple_loc, disciple_rot, disciple):

        bpy.ops.object.mode_set(mode='OBJECT')

        bpy.context.scene.frame_current = 0

        bpy.ops.object.select_all(action='DESELECT')
        rig.select_set(state=True)
        bpy.context.view_layer.objects.active = rig

        bpy.ops.object.editmode_toggle()

        parent_bone = 'y3y4' # choose the bone name which you want to be the parent

        rig.data.edit_bones.active = rig.data.edit_bones[parent_bone]

        bpy.ops.object.mode_set(mode='OBJECT')

        bpy.ops.object.select_all(action='DESELECT') #deselect all objects

        disciple.rig.select_set(state=True)

        rig.select_set(state=True)
        bpy.context.view_layer.objects.active = rig    #the active object will be the parent of all selected object

        bpy.ops.object.parent_set(type='BONE', keep_transform=True)

        bpy.ops.object.select_all(action='DESELECT') #deselect all objects

        # disciple position
        disciple.rig.location.x += disciple_loc[0]
        disciple.rig.location.y += disciple_loc[1]
        disciple.rig.location.z += disciple_loc[2]

        disciple.rig.rotation_euler = disciple_rot

    def configLink(self, A, J, helicity, rig, move, part):

        bpy.ops.object.mode_set(mode='OBJECT')
    
        Q = (0.18648+0.146446)*A
    #   Z = -Q*2
        Z = 0.0

        if part == 'right-upperforelimb':
            obj_joint = bpy.data.objects["joint.gold.a2a1.upperforelimb-right"].copy()
        else:
            obj_joint = bpy.data.objects["joint.gold.a2a1.upperforelimb-left"].copy()
        
        obj_joint.location = (0.0, 0.0, -Q*3+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "a2a1.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.silver.001"].copy()
        obj_joint.location = (0.0, 0.0, +Q+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "y1a2.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.copper.001"].copy()
        obj_joint.location = (0.0, 0.0, +Q*3+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "a2o1.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.blue.001"].copy()
        obj_joint.location = (0.0, 0.0, -Q*2+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "a1b1.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)


        for n in range(1, J - 1):

            if n <= (J-2):

                # Pattern 2 of by
                obj_joint = bpy.data.objects["joint.green.001"].copy()
                obj_joint.location = (0.0, 0.0, -Q + Q*((n+1) % 2)*4 +Z)
                obj_joint.scale = (A, A, A)
                obj_joint.name = "b"+str(n)+"y"+str(n)+".mesh." + move + '.' + part +'.' + helicity
                bpy.data.collections['link'].objects.link(obj_joint)

                # Pattern 2 of yy
                obj_joint = bpy.data.objects["joint.gold.00"+str(1 + (n+1) % 2)].copy()
                obj_joint.location = (0.0, 0.0, +Q*(1 - (n % 2))*2+Z)
                obj_joint.scale = (A, A, A)
                obj_joint.name = "y"+str(n)+"y"+str(n+1)+".mesh." + move + '.' + part +'.' + helicity
                bpy.data.collections['link'].objects.link(obj_joint)


            if n <= (J-3):

                # Pattern 1 of ob
                obj_joint = bpy.data.objects["joint.blue.001"].copy()
                obj_joint.location = (0.0, 0.0, -Q*2 + Q*(n % 2)*6 +Z)
                obj_joint.scale = (A, A, A)
                obj_joint.name = "o"+str(n)+"b"+str(n+1)+".mesh." + move + '.' + part +'.' + helicity
                bpy.data.collections['link'].objects.link(obj_joint)

                # Pattern 2 of yo
                obj_joint = bpy.data.objects["joint.copper.001"].copy()
                obj_joint.location = (0.0, 0.0, -Q + Q*((n+1) % 2)*4 +Z)
                obj_joint.scale = (A, A, A)
                obj_joint.name = "y"+str(n+1)+"o"+str(n+1)+".mesh." + move + '.' + part +'.' + helicity
                bpy.data.collections['link'].objects.link(obj_joint)


        for ob in data.collections['link'].objects:
            if "mesh" in ob.name:
                ob.select_set(state = True, view_layer = None)

        bpy.ops.object.make_single_user(type='SELECTED_OBJECTS', object=True, obdata=True, material=True, animation=True)
        bpy.context.scene.cursor.location = (0.0, 0.0, 0.0)
        bpy.ops.object.origin_set(type='ORIGIN_CURSOR')


class RightShoulder(Formula):

    J = 5 #joint number

    # Overriding
    def __init__(self, P, A, move, part, helicity, start, end,
            disciple_loc, disciple_rot, disciple):

        global interval
        global frame_start
        global frame_end

        self.interval = interval
        self.frame_start = frame_start
        self.frame_end = frame_end

        # pivot factor
        self.P = P

        # scale factor
        self.A = A 

        # name
        self.move = move

        # element
        self.part = part

        # element helicity
        self.helicity = helicity

        self.start = start
        self.end = end

        # disciple position
        self.disciple_loc = disciple_loc
        self.disciple_rot = disciple_rot

        # disciple
        self.disciple = disciple

        # Create armature and object
        self.amt = bpy.data.armatures.new(move + '.' + part + '.' + helicity + '.data')
        self.rig = bpy.data.objects.new(move + '.' + part + '.' + helicity, self.amt)

        # Joints
        self.a = [0 for i in range(4)] # Joint α
        self.b = [0 for i in range(self.J)] # Joint β
        self.y = [0 for i in range(self.J)] # Joint γ
        self.o = [0 for i in range(self.J)] # Joint δ

        # Configuration Movement
        self.configMovement(self.P, self.A, self.J, self.a, self.b, self.y, self.o)

        # Construction Movement
        self.constructMovement(self.J, self.helicity, self.amt, self.rig, self.a, self.b, self.y, self.o)

        # Parent set disciple to master       
        self.setParent(self.helicity, self.move, self.rig, self.disciple_loc, self.disciple_rot, self.disciple)

        # Construction Rotation
        self.configRotation(self.rig, self.interval, self.frame_start, self.frame_end, self.start, self.end)

        # Configuration Linkage
        self.configLink(self.A*0.8, self.J, self.helicity, self.rig, self.move, self.part)

        # Construction Linkage
        self.constructLink(self.A*0.8, self.J, self.helicity, self.rig, self.move, self.part)

    # Overriding Configuration Movement
    def configMovement(self, P, A, J, a, b, y, o):

        a[1] = mathutils.Euler((P, A, 0.0), 'XYZ')
        print ("a1 =", a[1])

        a[2] = mathutils.Euler((A, -A, 0.0), 'XYZ')
        print ("a2 =", a[2])

        b[1] = mathutils.Euler((-A, A, 0.0), 'XYZ')
        print ("b1 =", b[1])

        o[1] = mathutils.Euler((A, A, 0.0), 'XYZ')
        print ("o1 =", o[1])

        B = A * 2 * sqrt (2)
        C = B + (B * sqrt (2))
        D = C * sqrt (2)
        E = C + D
        
        y[1] = mathutils.Euler((-A, -A, 0.0), 'XYZ')
        print ("y1 =", y[1])

        b[2] = mathutils.Euler(((A*3/0.512329)*A, (A/0.512329)*A, 0.0), 'XYZ')
        print ("b2 =", b[2])

        b[3] = mathutils.Euler(((-A/0.512329)*A, (-3/0.512329)*A, 0.0), 'XYZ')
        print ("b3 =", b[3])
        
        y[2] = mathutils.Euler(((A/0.512329)*A, (-A/0.512329)*A, 0.0), 'XYZ')
        print ("y2 =", y[2])

        y[3] = mathutils.Euler(((A/0.512329)*A, (-3/0.512329)*A, 0.0), 'XYZ')
        print ("y3 =", y[3])

        o[2] = mathutils.Euler(((-A/0.512329)*A, (-A/0.512329)*A, 0.0), 'XYZ')
        print ("o2 =", o[2])
        
        o[3] = mathutils.Euler(((A/0.512329)*A, (-4.03054/0.512329)*A, 0.0), 'XYZ')
        print ("o3 =", o[3])
        
        y[4] = mathutils.Euler(((A*3/0.512329)*A, (-3/0.512329)*A, 0.0), 'XYZ')
        print ("y4 =", y[4])

    # Parent set disciple to master        
    def setParent(self, helicity, move, rig, disciple_loc, disciple_rot, disciple):

        bpy.ops.object.mode_set(mode='OBJECT')

        bpy.context.scene.frame_current = 0

        bpy.ops.object.select_all(action='DESELECT')
        rig.select_set(state=True)
        bpy.context.view_layer.objects.active = rig

        bpy.ops.object.editmode_toggle()

        parent_bone = 'b3y3' # choose the bone name which you want to be the parent

        rig.data.edit_bones.active = rig.data.edit_bones[parent_bone]

        bpy.ops.object.mode_set(mode='OBJECT')

        bpy.ops.object.select_all(action='DESELECT') #deselect all objects

        disciple.rig.select_set(state=True)

        rig.select_set(state=True)
        bpy.context.view_layer.objects.active = rig    #the active object will be the parent of all selected object

        bpy.ops.object.parent_set(type='BONE', keep_transform=True)

        bpy.ops.object.select_all(action='DESELECT') #deselect all objects

        # disciple position
        disciple.rig.location.x += disciple_loc[0]
        disciple.rig.location.y += disciple_loc[1]
        disciple.rig.location.z += disciple_loc[2]

        disciple.rig.rotation_euler = disciple_rot

    def configLink(self, A, J, helicity, rig, move, part):

        bpy.ops.object.mode_set(mode='OBJECT')
    
        Q = (0.18648+0.146446)*A
    #   Z = -Q*2
        Z = 0.0

        obj_joint = bpy.data.objects["joint.gold.000"].copy()
        obj_joint.location = (0.0, 0.0, -Q*0+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "a2a1.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.silver.002"].copy()
        obj_joint.location = (0.0, 0.0, +Q*4+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "y1a2.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.copper.001"].copy()
        obj_joint.location = (0.0, 0.0, +Q*6+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "a2o1.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.blue.001"].copy()
        obj_joint.location = (0.0, 0.0, +Q*1+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "a1b1.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)


        for n in range(1, J - 1):

            if n <= (J-2):

                if n == 1:
                    
                    obj_joint = bpy.data.objects["joint.green.002"].copy()
                    obj_joint.location = (0.0, 0.0, +Q*2 + Q*((n+1) % 2)*4 +Z)
                    obj_joint.scale = (A, A, A)
                    obj_joint.name = "b"+str(n)+"y"+str(n)+".mesh." + move + '.' + part +'.' + helicity
                    bpy.data.collections['link'].objects.link(obj_joint)                    

                else:
                    # Pattern 2 of by
                    obj_joint = bpy.data.objects["joint.green.001"].copy()
                    obj_joint.location = (0.0, 0.0, -Q + Q*((n+1) % 2)*4 +Z)
                    obj_joint.scale = (A, A, A)
                    obj_joint.name = "b"+str(n)+"y"+str(n)+".mesh." + move + '.' + part +'.' + helicity
                    bpy.data.collections['link'].objects.link(obj_joint)

            if n <= (J-3):

                # Pattern 2 of yy
                obj_joint = bpy.data.objects["joint.gold.00"+str(1 + (n+1) % 2)].copy()
                obj_joint.location = (0.0, 0.0, +Q*(1 - (n % 2))*2+Z)
                obj_joint.scale = (A, A, A)
                obj_joint.name = "y"+str(n)+"y"+str(n+1)+".mesh." + move + '.' + part +'.' + helicity
                bpy.data.collections['link'].objects.link(obj_joint)

                if n == 1:
                    # Pattern 1 of ob
                    obj_joint = bpy.data.objects["joint.blue.002"].copy()
                    obj_joint.location = (0.0, 0.0, +Q*1 + Q*(n % 2)*6 +Z)
                    obj_joint.scale = (A, A, A)
                    obj_joint.name = "o"+str(n)+"b"+str(n+1)+".mesh." + move + '.' + part +'.' + helicity
                    bpy.data.collections['link'].objects.link(obj_joint)

                else:
                    # Pattern 1 of ob
                    obj_joint = bpy.data.objects["joint.blue.001"].copy()
                    obj_joint.location = (0.0, 0.0, -Q*2 + Q*(n % 2)*6 +Z)
                    obj_joint.scale = (A, A, A)
                    obj_joint.name = "o"+str(n)+"b"+str(n+1)+".mesh." + move + '.' + part +'.' + helicity
                    bpy.data.collections['link'].objects.link(obj_joint)

                # Pattern 2 of yo
                obj_joint = bpy.data.objects["joint.copper.001"].copy()
                obj_joint.location = (0.0, 0.0, -Q + Q*((n+1) % 2)*4 +Z)
                obj_joint.scale = (A, A, A)
                obj_joint.name = "y"+str(n+1)+"o"+str(n+1)+".mesh." + move + '.' + part +'.' + helicity
                bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.gold.spine.y3y4"].copy()
        obj_joint.location = (0.0, 0.0, +Q*(1 - (3 % 2))*2+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "y3y4.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)


        for ob in data.collections['link'].objects:
            if "mesh" in ob.name:
                ob.select_set(state = True, view_layer = None)

        bpy.ops.object.make_single_user(type='SELECTED_OBJECTS', object=True, obdata=True, material=True, animation=True)
        bpy.context.scene.cursor.location = (0.0, 0.0, 0.0)
        bpy.ops.object.origin_set(type='ORIGIN_CURSOR')


class LeftShoulder(RightShoulder):

    J = 5 #joint number

    # Overriding
    def __init__(self, P, A, move, part, helicity, start, end,
            disciple_loc, disciple_rot, disciple, disciple2_loc, disciple2_rot, disciple2):

        global interval
        global frame_start
        global frame_end

        self.interval = interval
        self.frame_start = frame_start
        self.frame_end = frame_end

        # pivot factor
        self.P = P

        # scale factor
        self.A = A 

        # name
        self.move = move

        # element
        self.part = part

        # element helicity
        self.helicity = helicity

        self.start = start
        self.end = end

        # disciple position
        self.disciple_loc = disciple_loc
        self.disciple_rot = disciple_rot

        # disciple
        self.disciple = disciple
        
        # disciple position
        self.disciple2_loc = disciple2_loc
        self.disciple2_rot = disciple2_rot

        # disciple
        self.disciple2 = disciple2

        # Create armature and object
        self.amt = bpy.data.armatures.new(move + '.' + part + '.' + helicity + '.data')
        self.rig = bpy.data.objects.new(move + '.' + part + '.' + helicity, self.amt)

        # Joints
        self.a = [0 for i in range(4)] # Joint α
        self.b = [0 for i in range(self.J)] # Joint β
        self.y = [0 for i in range(self.J)] # Joint γ
        self.o = [0 for i in range(self.J)] # Joint δ

        # Configuration Movement
        self.configMovement(self.P, self.A, self.J, self.a, self.b, self.y, self.o)

        # Construction Movement
        self.constructMovement(self.J, self.helicity, self.amt, self.rig, self.a, self.b, self.y, self.o)

        # Parent set disciple to master       
        self.setParent(self.helicity, self.move, self.rig, self.disciple_loc, self.disciple_rot,
            self.disciple, self.disciple2_loc, self.disciple2_rot, self.disciple2)

        # Construction Rotation
        self.configRotation(self.rig, self.interval, self.frame_start, self.frame_end, self.start, self.end)

        # Configuration Linkage
        self.configLink(self.A*0.8, self.J, self.helicity, self.rig, self.move, self.part)

        # Construction Linkage
        self.constructLink(self.A*0.8, self.J, self.helicity, self.rig, self.move, self.part)

    # Overriding Configuration Movement
    def configMovement(self, P, A, J, a, b, y, o):

        a[1] = mathutils.Euler((P, A, 0.0), 'XYZ')
        print ("a1 =", a[1])

        a[2] = mathutils.Euler((A, -A, 0.0), 'XYZ')
        print ("a2 =", a[2])

        b[1] = mathutils.Euler((-A, A, 0.0), 'XYZ')
        print ("b1 =", b[1])

        o[1] = mathutils.Euler((A, A, 0.0), 'XYZ')
        print ("o1 =", o[1])

        B = A * 2 * sqrt (2)
        C = B + (B * sqrt (2))
        D = C * sqrt (2)
        E = C + D
        
        y[1] = mathutils.Euler((-A, -A, 0.0), 'XYZ')
        print ("y1 =", y[1])

        b[2] = mathutils.Euler(((A*3/0.512329)*A, (A/0.512329)*A, 0.0), 'XYZ')
        print ("b2 =", b[2])

        b[3] = mathutils.Euler(((-A/0.512329)*A, (1.97543/0.512329)*A, 0.0), 'XYZ')
        print ("b3 =", b[3])
        
        y[2] = mathutils.Euler(((A/0.512329)*A, (-A/0.512329)*A, 0.0), 'XYZ')
        print ("y2 =", y[2])

        y[3] = mathutils.Euler(((A/0.512329)*A, (1.97543/0.512329)*A, 0.0), 'XYZ')
        print ("y3 =", y[3])

        o[2] = mathutils.Euler(((-A/0.512329)*A, (-A/0.512329)*A, 0.0), 'XYZ')
        print ("o2 =", o[2])
        
        o[3] = mathutils.Euler(((A/0.512329)*A, (3/0.512329)*A, 0.0), 'XYZ')
        print ("o3 =", o[3])
        
        y[4] = mathutils.Euler(((A*3/0.512329)*A, (1.97543/0.512329)*A, 0.0), 'XYZ')
        print ("y4 =", y[4])

    # Parent set disciple to master
    def setParent(self, helicity, move, rig, disciple_loc, disciple_rot, disciple, 
            disciple2_loc, disciple2_rot, disciple2):

        bpy.ops.object.mode_set(mode='OBJECT')

        bpy.context.scene.frame_current = 0

        bpy.ops.object.select_all(action='DESELECT')
        rig.select_set(state=True)
        bpy.context.view_layer.objects.active = rig

        bpy.ops.object.editmode_toggle()

        parent_bone = 'a2a1' # choose the bone name which you want to be the parent

        rig.data.edit_bones.active = rig.data.edit_bones[parent_bone]

        bpy.ops.object.mode_set(mode='OBJECT')

        bpy.ops.object.select_all(action='DESELECT') #deselect all objects

        #disciple
        disciple.rig.select_set(state=True)

        rig.select_set(state=True)
        bpy.context.view_layer.objects.active = rig    #the active object will be the parent of all selected object

        bpy.ops.object.parent_set(type='BONE', keep_transform=True)

        bpy.ops.object.select_all(action='DESELECT') #deselect all objects

        # disciple position
        disciple.rig.location.x += disciple_loc[0]
        disciple.rig.location.y += disciple_loc[1]
        disciple.rig.location.z += disciple_loc[2]

        disciple.rig.rotation_euler = disciple_rot
        

        bpy.ops.object.mode_set(mode='OBJECT')

        bpy.context.scene.frame_current = 0

        bpy.ops.object.select_all(action='DESELECT')
        rig.select_set(state=True)
        bpy.context.view_layer.objects.active = rig

        bpy.ops.object.editmode_toggle()

        parent_bone = 'b3y3' # choose the bone name which you want to be the parent

        rig.data.edit_bones.active = rig.data.edit_bones[parent_bone]

        bpy.ops.object.mode_set(mode='OBJECT')

        bpy.ops.object.select_all(action='DESELECT') #deselect all objects

        #disciple2
        disciple2.rig.select_set(state=True)

        rig.select_set(state=True)
        bpy.context.view_layer.objects.active = rig    #the active object will be the parent of all selected object

        bpy.ops.object.parent_set(type='BONE', keep_transform=True)

        bpy.ops.object.select_all(action='DESELECT') #deselect all objects

        # disciple2 position
        disciple2.rig.location.x += disciple2_loc[0]
        disciple2.rig.location.y += disciple2_loc[1]
        disciple2.rig.location.z += disciple2_loc[2]

        disciple2.rig.rotation_euler = disciple2_rot
        

class Head(Formula):

    J = 6 #joint number

    # Overriding
    def __init__(self, P, A, move, part, helicity, start, end):

        global interval
        global frame_start
        global frame_end

        self.interval = interval
        self.frame_start = frame_start
        self.frame_end = frame_end

        # pivot factor
        self.P = P

        # scale factor
        self.A = A 

        # name
        self.move = move

        # element
        self.part = part

        # element helicity
        self.helicity = helicity

        self.start = start
        self.end = end

        # Create armature and object
        self.amt = bpy.data.armatures.new(move + '.' + part + '.' + helicity + '.data')
        self.rig = bpy.data.objects.new(move + '.' + part + '.' + helicity, self.amt)

        # Joints
        self.a = [0 for i in range(4)] # Joint α
        self.b = [0 for i in range(self.J)] # Joint β
        self.y = [0 for i in range(self.J)] # Joint γ
        self.o = [0 for i in range(self.J)] # Joint δ

        # Configuration Movement
        self.configMovement(self.P, self.A, self.J, self.a, self.b, self.y, self.o)

        # Construction Movement
        self.constructMovement(self.J, self.helicity, self.amt, self.rig, self.a, self.b, self.y, self.o)

        # Construction Rotation
        self.configRotation(self.rig, self.interval, self.frame_start, self.frame_end, self.start, self.end)

        # Configuration Linkage
        self.configLink(1.4*self.A, self.J, self.helicity, self.rig, self.move, self.part)

        # Construction Linkage
        self.constructLink(1.4*self.A, self.J, self.helicity, self.rig, self.move, self.part)

    # Overriding Configuration Movement
    def configMovement(self, P, A, J, a, b, y, o):

        a[1] = mathutils.Euler((P, A, 0.0), 'XYZ')
        print ("a1 =", a[1])

        a[2] = mathutils.Euler((A, -A, 0.0), 'XYZ')
        print ("a2 =", a[2])

        b[1] = mathutils.Euler((-A, A, 0.0), 'XYZ')
        print ("b1 =", b[1])

        o[1] = mathutils.Euler((A, A, 0.0), 'XYZ')
        print ("o1 =", o[1])

        B = A * 2 * sqrt (2)
        C = B + (B * sqrt (2))
        D = C * sqrt (2)
        E = C + D

        y[1] = mathutils.Euler((-A, -A, 0.0), 'XYZ')
        print ("y1 =", y[1])
        
        b[2] = mathutils.Euler(((3.354023/0.476741)*A, (-2.400706/0.476741)*A, 0.0), 'XYZ')
        print ("b2 =", b[2])

        b[3] = mathutils.Euler(((14.608374/0.476741)*A, (-8.410717/0.476741)*A, 0.0), 'XYZ')
        print ("b3 =", b[3])

        b[4] = mathutils.Euler(((6.742701/0.476741)*A, (-17.577248/0.476741)*A, 0.0), 'XYZ')
        print ("b4 =", b[4])

        y[2] = mathutils.Euler(((2.400629/0.476741)*A, (-3.3541/0.476741)*A, 0.0), 'XYZ')
        print ("y2 =", y[2])

        y[3] = mathutils.Euler(((11.032801/0.476741)*A, (-11.9863/0.476741)*A, 0.0), 'XYZ')
        print ("y3 =", y[3])

        y[4] = mathutils.Euler(((5.394285/0.476741)*A, (-15.241665/0.476741)*A, 0.0), 'XYZ')
        print ("y4 =", y[4])

        y[5] = mathutils.Euler(((4.080432/0.476741)*A, (-15.544949/0.476741)*A, 0.0), 'XYZ')
        print ("y5 =", y[5])

        o[2] = mathutils.Euler(((5.976194/0.476741)*A, (0.221443/0.476741)*A, 0.0), 'XYZ')
        print ("o2 =", o[2])

        o[3] = mathutils.Euler(((12.381183/0.476741)*A, (-14.321769/0.476741)*A, 0.0), 'XYZ')
        print ("o3 =", o[3])
    
        o[4] = mathutils.Euler(((4.226511/0.476741)*A, (-15.915896/0.476741)*A, 0.0), 'XYZ')
        print ("o4 =", o[4])

    def configLink(self, A, J, helicity, rig, move, part):

        bpy.ops.object.mode_set(mode='OBJECT')
    
        Q = (0.18648+0.146446)*A
    #   Z = -Q*2
        Z = 0.0

        obj_joint = bpy.data.objects["joint.gold.a2a1.head"].copy()
        
        obj_joint.location = (0.0, 0.0, -Q*3+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "a2a1.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.silver.001"].copy()
        obj_joint.location = (0.0, 0.0, +Q+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "y1a2.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.copper.001"].copy()
        obj_joint.location = (0.0, 0.0, +Q*3+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "a2o1.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.blue.001"].copy()
        obj_joint.location = (0.0, 0.0, -Q*2+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "a1b1.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)


        for n in range(1, J - 1):

            if n <= (J-2):

                # Pattern 2 of by
                obj_joint = bpy.data.objects["joint.green.001"].copy()
                obj_joint.location = (0.0, 0.0, -Q + Q*((n+1) % 2)*4 +Z)
                obj_joint.scale = (A, A, A)
                obj_joint.name = "b"+str(n)+"y"+str(n)+".mesh." + move + '.' + part +'.' + helicity
                bpy.data.collections['link'].objects.link(obj_joint)

                # Pattern 2 of yy
                obj_joint = bpy.data.objects["joint.gold.00"+str(1 + (n+1) % 2)].copy()
                obj_joint.location = (0.0, 0.0, +Q*(1 - (n % 2))*2+Z)
                obj_joint.scale = (A, A, A)
                obj_joint.name = "y"+str(n)+"y"+str(n+1)+".mesh." + move + '.' + part +'.' + helicity
                bpy.data.collections['link'].objects.link(obj_joint)


            if n <= (J-3):

                # Pattern 1 of ob
                obj_joint = bpy.data.objects["joint.blue.001"].copy()
                obj_joint.location = (0.0, 0.0, -Q*2 + Q*(n % 2)*6 +Z)
                obj_joint.scale = (A, A, A)
                obj_joint.name = "o"+str(n)+"b"+str(n+1)+".mesh." + move + '.' + part +'.' + helicity
                bpy.data.collections['link'].objects.link(obj_joint)

                # Pattern 2 of yo
                obj_joint = bpy.data.objects["joint.copper.001"].copy()
                obj_joint.location = (0.0, 0.0, -Q + Q*((n+1) % 2)*4 +Z)
                obj_joint.scale = (A, A, A)
                obj_joint.name = "y"+str(n+1)+"o"+str(n+1)+".mesh." + move + '.' + part +'.' + helicity
                bpy.data.collections['link'].objects.link(obj_joint)


        for ob in data.collections['link'].objects:
            if "mesh" in ob.name:
                ob.select_set(state = True, view_layer = None)

        bpy.ops.object.make_single_user(type='SELECTED_OBJECTS', object=True, obdata=True, material=True, animation=True)
        bpy.context.scene.cursor.location = (0.0, 0.0, 0.0)
        bpy.ops.object.origin_set(type='ORIGIN_CURSOR')
        

class Neck(Formula):

    J = 3 #joint number

    # Overriding
    def __init__(self, P, A, move, part, helicity, start, end, 
        disciple_loc, disciple_rot, disciple):

        global interval
        global frame_start
        global frame_end

        self.interval = interval
        self.frame_start = frame_start
        self.frame_end = frame_end

        # pivot factor
        self.P = P

        # scale factor
        self.A = A 

        # name
        self.move = move

        # element
        self.part = part

        # element helicity
        self.helicity = helicity

        self.start = start
        self.end = end

        # disciple position
        self.disciple_loc = disciple_loc
        self.disciple_rot = disciple_rot

        # disciple
        self.disciple = disciple

        # Create armature and object
        self.amt = bpy.data.armatures.new(move + '.' + part + '.' + helicity + '.data')
        self.rig = bpy.data.objects.new(move + '.' + part + '.' + helicity, self.amt)

        # Joints
        self.a = [0 for i in range(self.J)] # Joint α
        self.b = [0 for i in range(self.J)] # Joint β
        self.y = [0 for i in range(self.J)] # Joint γ
        self.o = [0 for i in range(self.J)] # Joint δ

        # Configuration Movement
        self.configMovement(self.P, self.A, self.J, self.a, self.b, self.y, self.o)

        # Construction Movement
        self.constructMovement(self.J, self.helicity, self.amt, self.rig, self.a, self.b, self.y, self.o)

        # Parent set disciple to master        
        self.setParent(self.helicity, self.move, self.rig, 
            self.disciple_loc, self.disciple_rot, self.disciple)

        # Construction Rotation
        self.configRotation(self.rig, self.interval, self.frame_start, self.frame_end, self.start, self.end)

        # Configuration Linkage
        self.configLink(1.25*self.A*0.4, self.J, self.helicity, self.rig, self.move, self.part)

        # Construction Linkage
        self.constructLink(1.25*self.A*0.4, self.J, self.helicity, self.rig, self.move, self.part)

    # Overriding Configuration Movement
    def configMovement(self, P, A, J, a, b, y, o):

        a[1] = mathutils.Euler((P, A, 0.0), 'XYZ')
        print ("a1 =", a[1])

        a[2] = mathutils.Euler((A, -A, 0.0), 'XYZ')
        print ("a2 =", a[2])

        b[1] = mathutils.Euler((-A, A, 0.0), 'XYZ')
        print ("b1 =", b[1])

        B = A * 2 * sqrt (2)
        C = B + (B * sqrt (2))
        D = C * sqrt (2)
        E = C + D

        y[1] = mathutils.Euler((-A, -A, 0.0), 'XYZ')
        print ("y1 =", y[1])
        
        y[2] = mathutils.Euler((-A, -(0.470026/0.953482)*A, 0.0), 'XYZ')
        print ("y2 =", y[2])

        o[1] = mathutils.Euler(((-2.10399/0.953482)*A, -A, 0.0), 'XYZ')
        print ("o1 =", o[1])

    def constructMovement(self, J, helicity, amt, rig, a, b, y, o):

        # Linkages
        aa = [[0 for i in range(4)] for j in range(4)] # Link α(i) - α(j)
        ab = [[0 for i in range(4)] for j in range(4)] # Link α(i) - β(j)
        ya = [[0 for i in range(4)] for j in range(4)] # Link γ(i) - α(j)
        yy = [[0 for i in range(self.J)] for j in range(self.J)] # Link γ(i) - γ(j)
        by = [[0 for i in range(self.J)] for j in range(self.J)] # Link β(i) - γ(j)
        yo = [[0 for i in range(self.J)] for j in range(self.J)] # Link γ(i) - δ(j)

        rig.location = mathutils.Euler((0.0, 0.0, 0.0), 'XYZ')
        rig.show_in_front = True
        amt.show_names = True
        amt.display_type = 'STICK'
#        amt.display_type = 'BBONE'

        # Link object to scene

        bpy.data.collections['movement'].objects.link(rig)
        bpy.context.view_layer.objects.active = rig
        bpy.context.view_layer.update()

        # Edit
        bpy.ops.object.editmode_toggle()

        # Construction Linkage
        aa[2][1] = amt.edit_bones.new('a2a1')
        aa[2][1].head = a[2]
        aa[2][1].tail = a[1]
        
        ab[1][1] = amt.edit_bones.new('a1b1')
        ab[1][1].head = a[1]
        ab[1][1].tail = b[1]
        ab[1][1].parent = aa[2][1]
 
        by[1][1] = amt.edit_bones.new('b1y1')
        by[1][1].head = b[1]
        by[1][1].tail = y[1]
        by[1][1].parent = ab[1][1]
        by[1][1].use_inherit_rotation = False

        ya[1][2] = amt.edit_bones.new('y1a2')
        ya[1][2].head = y[1]
        ya[1][2].tail = a[2]
        ya[1][2].parent = by[1][1]

        yo[1][1] = amt.edit_bones.new('y1o1')
        yo[1][1].head = y[1]
        yo[1][1].tail = o[1]
        yo[1][1].parent = by[1][1]
   
        yy[1][2] = amt.edit_bones.new('y1y2')
        yy[1][2].head = y[1]
        yy[1][2].tail = y[2]
        yy[1][2].parent = by[1][1]

        # all bones select

        # Bone constraints. Armature must be in pose mode.
        bpy.ops.object.mode_set(mode='POSE')

        bpy.ops.pose.select_all(action="SELECT")

        # Edit
        bpy.ops.object.editmode_toggle()

        if helicity == 'right':
            bpy.ops.armature.calculate_roll(type='GLOBAL_POS_Z')
        else:
            bpy.ops.armature.calculate_roll(type='GLOBAL_NEG_Z')
 
        # IK constraint
        cns = rig.pose.bones['y1a2'].constraints.new('IK')
        cns.name = 'Ik'
        cns.target = rig
        cns.subtarget = 'a2a1'
        cns.chain_count = 2
        cns.use_stretch = False

        bpy.ops.object.mode_set(mode='OBJECT')

    # Parent set disciple to master        
    def setParent(self, helicity, move, rig, disciple_loc, disciple_rot, disciple):

        bpy.ops.object.mode_set(mode='OBJECT')

        bpy.context.scene.frame_current = 0

        bpy.ops.object.select_all(action='DESELECT')
        rig.select_set(state=True)
        bpy.context.view_layer.objects.active = rig

        bpy.ops.object.editmode_toggle()

        parent_bone = 'y1a2' # choose the bone name which you want to be the parent

        rig.data.edit_bones.active = rig.data.edit_bones[parent_bone]

        bpy.ops.object.mode_set(mode='OBJECT')

        bpy.ops.object.select_all(action='DESELECT') #deselect all objects

        disciple.rig.select_set(state=True)

        rig.select_set(state=True)
        bpy.context.view_layer.objects.active = rig    #the active object will be the parent of all selected object

        bpy.ops.object.parent_set(type='BONE', keep_transform=True)

        bpy.ops.object.select_all(action='DESELECT') #deselect all objects

        # disciple position
        disciple.rig.location.x += disciple_loc[0]
        disciple.rig.location.y += disciple_loc[1]
        disciple.rig.location.z += disciple_loc[2]

        disciple.rig.rotation_euler = disciple_rot

    def configLink(self, A, J, helicity, rig, move, part):

        bpy.ops.object.mode_set(mode='OBJECT')
    
        Q = (0.18648+0.146446)*A
    #   Z = -Q*2
        Z = 0.0

        obj_joint = bpy.data.objects["joint.gold.000"].copy()
        obj_joint.location = (0.0, 0.0, -Q*3+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "a2a1.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.silver.001"].copy()
        obj_joint.location = (0.0, 0.0, +Q+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "y1a2.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.copper.y1o1"].copy()
        obj_joint.location = (0.0, 0.0, +Q*3+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "y1o1.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.blue.001"].copy()
        obj_joint.location = (0.0, 0.0, -Q*2+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "a1b1.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        n = 1

        # Pattern 2 of by
        obj_joint = bpy.data.objects["joint.green.001"].copy()
        obj_joint.location = (0.0, 0.0, -Q + Q*((n+1) % 2)*4 +Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "b"+str(n)+"y"+str(n)+".mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        # Pattern 2 of yy
        obj_joint = bpy.data.objects["joint.gold.00"+str(1 + (n+1) % 2)].copy()
        obj_joint.location = (0.0, 0.0, +Q*(1 - (n % 2))*2+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "y"+str(n)+"y"+str(n+1)+".mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        for ob in data.collections['link'].objects:
            if "mesh" in ob.name:
                ob.select_set(state = True, view_layer = None)

        bpy.ops.object.make_single_user(type='SELECTED_OBJECTS', object=True, obdata=True, material=True, animation=True)
        bpy.context.scene.cursor.location = (0.0, 0.0, 0.0)
        bpy.ops.object.origin_set(type='ORIGIN_CURSOR')


class LowerHindlimb(Formula):

    J = 6 #joint number

    # Overriding
    def __init__(self, P, A, move, part, helicity, start, end):

        global interval
        global frame_start
        global frame_end

        self.interval = interval
        self.frame_start = frame_start
        self.frame_end = frame_end

        # pivot factor
        self.P = P

        # scale factor
        self.A = A 

        # name
        self.move = move

        # element
        self.part = part

        # element helicity
        self.helicity = helicity

        self.start = start
        self.end = end

        # Create armature and object
        self.amt = bpy.data.armatures.new(move + '.' + part + '.' + helicity + '.data')
        self.rig = bpy.data.objects.new(move + '.' + part + '.' + helicity, self.amt)

        # Joints
        self.a = [0 for i in range(4)] # Joint α
        self.b = [0 for i in range(self.J)] # Joint β
        self.y = [0 for i in range(self.J)] # Joint γ
        self.o = [0 for i in range(self.J)] # Joint δ

        # Configuration Movement
        self.configMovement(self.P, self.A, self.J, self.a, self.b, self.y, self.o)

        # Construction Movement
        self.constructMovement(self.J, self.helicity, self.amt, self.rig, self.a, self.b, self.y, self.o)

        # Construction Rotation
        self.configRotation(self.rig, self.interval, self.frame_start, self.frame_end, self.start, self.end)

        # Configuration Linkage
        self.configLink(1.8*self.A, self.J, self.helicity, self.rig, self.move, self.part)

        # Construction Linkage
        self.constructLink(1.8*self.A, self.J, self.helicity, self.rig, self.move, self.part)

    # Overriding Configuration Movement
    def configMovement(self, P, A, J, a, b, y, o):

        a[1] = mathutils.Euler((P, A, 0.0), 'XYZ')
        print ("a1 =", a[1])

        a[2] = mathutils.Euler((A, -A, 0.0), 'XYZ')
        print ("a2 =", a[2])

        b[1] = mathutils.Euler((-A, A, 0.0), 'XYZ')
        print ("b1 =", b[1])

        o[1] = mathutils.Euler((A, A, 0.0), 'XYZ')
        print ("o1 =", o[1])

        B = A * 2 * sqrt (2)
        C = B + (B * sqrt (2))
        D = C * sqrt (2)
        E = C + D

        y[1] = mathutils.Euler((-A, -A, 0.0), 'XYZ')
        print ("y1 =", y[1])
        
        b[2] = mathutils.Euler(((1.05/0.35)*A, A, 0.0), 'XYZ')
        print ("b2 =", b[2])

        b[3] = mathutils.Euler(((0.7/0.35)*A, (-1.19497/0.35)*A, 0.0), 'XYZ')
        print ("b3 =", b[3])

        b[4] = mathutils.Euler(((5.0818/0.35)*A, (-6.77175/0.35)*A, 0.0), 'XYZ')
        print ("b4 =", b[4])

        y[2] = mathutils.Euler((A, -A, 0.0), 'XYZ')
        print ("y2 =", y[2])

        y[3] = mathutils.Euler(((1.19497/0.35)*A, (-1.19497/0.35)*A, 0.0), 'XYZ')
        print ("y3 =", y[3])

        y[4] = mathutils.Euler(((5.92677/0.35)*A, (-5.92677/0.35)*A, 0.0), 'XYZ')
        print ("y4 =", y[4])

        y[5] = mathutils.Euler(((7.633759/0.35)*A, (-7.633759/0.35)*A, 0.0), 'XYZ')
        print ("y5 =", y[5])

        o[2] = mathutils.Euler(((0.7/0.35)*A, 0.0, 0.0), 'XYZ')
        print ("o2 =", o[2])

        o[3] = mathutils.Euler(((0.35/0.35)*A, (-2.03995/0.35)*A, 0.0), 'XYZ')
        print ("o3 =", o[3])
    
        o[4] = mathutils.Euler(((5.92677/0.35)*A, (-7.12175/0.35)*A, 0.0), 'XYZ')
        print ("o4 =", o[4])

    def configLink(self, A, J, helicity, rig, move, part):

        bpy.ops.object.mode_set(mode='OBJECT')
    
        Q = (0.18648+0.146446)*A
    #   Z = -Q*2
        Z = 0.0

        if part == 'right-lowerhindlimb':
            obj_joint = bpy.data.objects["joint.gold.a2a1.lowerhindlimb-right"].copy()
        else:
            obj_joint = bpy.data.objects["joint.gold.a2a1.lowerhindlimb-left"].copy()
        
        obj_joint.location = (0.0, 0.0, -Q*3+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "a2a1.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.silver.001"].copy()
        obj_joint.location = (0.0, 0.0, +Q+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "y1a2.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.copper.001"].copy()
        obj_joint.location = (0.0, 0.0, +Q*3+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "a2o1.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.blue.001"].copy()
        obj_joint.location = (0.0, 0.0, -Q*2+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "a1b1.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)


        for n in range(1, J - 1):

            if n <= (J-2):

                # Pattern 2 of by
                obj_joint = bpy.data.objects["joint.green.001"].copy()
                obj_joint.location = (0.0, 0.0, -Q + Q*((n+1) % 2)*4 +Z)
                obj_joint.scale = (A, A, A)
                obj_joint.name = "b"+str(n)+"y"+str(n)+".mesh." + move + '.' + part +'.' + helicity
                bpy.data.collections['link'].objects.link(obj_joint)

                # Pattern 2 of yy
                obj_joint = bpy.data.objects["joint.gold.00"+str(1 + (n+1) % 2)].copy()
                obj_joint.location = (0.0, 0.0, +Q*(1 - (n % 2))*2+Z)
                obj_joint.scale = (A, A, A)
                obj_joint.name = "y"+str(n)+"y"+str(n+1)+".mesh." + move + '.' + part +'.' + helicity
                bpy.data.collections['link'].objects.link(obj_joint)


            if n <= (J-3):

                # Pattern 1 of ob
                obj_joint = bpy.data.objects["joint.blue.001"].copy()
                obj_joint.location = (0.0, 0.0, -Q*2 + Q*(n % 2)*6 +Z)
                obj_joint.scale = (A, A, A)
                obj_joint.name = "o"+str(n)+"b"+str(n+1)+".mesh." + move + '.' + part +'.' + helicity
                bpy.data.collections['link'].objects.link(obj_joint)

                # Pattern 2 of yo
                obj_joint = bpy.data.objects["joint.copper.001"].copy()
                obj_joint.location = (0.0, 0.0, -Q + Q*((n+1) % 2)*4 +Z)
                obj_joint.scale = (A, A, A)
                obj_joint.name = "y"+str(n+1)+"o"+str(n+1)+".mesh." + move + '.' + part +'.' + helicity
                bpy.data.collections['link'].objects.link(obj_joint)


        for ob in data.collections['link'].objects:
            if "mesh" in ob.name:
                ob.select_set(state = True, view_layer = None)

        bpy.ops.object.make_single_user(type='SELECTED_OBJECTS', object=True, obdata=True, material=True, animation=True)
        bpy.context.scene.cursor.location = (0.0, 0.0, 0.0)
        bpy.ops.object.origin_set(type='ORIGIN_CURSOR')


class UpperHindlimb(Formula):

    J = 5 #joint number

    # Overriding
    def __init__(self, P, A, move, part, helicity, start, end, disciple_loc, disciple_rot, disciple):

        global interval
        global frame_start
        global frame_end

        self.interval = interval
        self.frame_start = frame_start
        self.frame_end = frame_end

        # pivot factor
        self.P = P

        # scale factor
        self.A = A 

        # name
        self.move = move

        # element
        self.part = part

        # element helicity
        self.helicity = helicity

        self.start = start
        self.end = end

        # disciple position
        self.disciple_loc = disciple_loc
        self.disciple_rot = disciple_rot

        # disciple
        self.disciple = disciple

        # Create armature and object
        self.amt = bpy.data.armatures.new(move + '.' + part + '.' + helicity + '.data')
        self.rig = bpy.data.objects.new(move + '.' + part + '.' + helicity, self.amt)

        # Joints
        self.a = [0 for i in range(4)] # Joint α
        self.b = [0 for i in range(self.J)] # Joint β
        self.y = [0 for i in range(self.J)] # Joint γ
        self.o = [0 for i in range(self.J)] # Joint δ

        # Configuration Movement
        self.configMovement(self.P, self.A, self.J, self.a, self.b, self.y, self.o)

        # Construction Movement
        self.constructMovement(self.J, self.helicity, self.amt, self.rig, self.a, self.b, self.y, self.o)

        # Parent set disciple to master       
        self.setParent(self.helicity, self.move, self.rig, self.disciple_loc, self.disciple_rot, self.disciple)

        # Construction Rotation
        self.configRotation(self.rig, self.interval, self.frame_start, self.frame_end, self.start, self.end)

        # Configuration Linkage
        self.configLink(1.25*self.A, self.J, self.helicity, self.rig, self.move, self.part)

        # Construction Linkage
        self.constructLink(1.25*self.A, self.J, self.helicity, self.rig, self.move, self.part)

    # Overriding Configuration Movement
    def configMovement(self, P, A, J, a, b, y, o):

        a[1] = mathutils.Euler((P, A, 0.0), 'XYZ')
        print ("a1 =", a[1])

        a[2] = mathutils.Euler((A, -A, 0.0), 'XYZ')
        print ("a2 =", a[2])

        b[1] = mathutils.Euler((-A, A, 0.0), 'XYZ')
        print ("b1 =", b[1])

        o[1] = mathutils.Euler((A, A, 0.0), 'XYZ')
        print ("o1 =", o[1])

        B = A * 2 * sqrt (2)
        C = B + (B * sqrt (2))
        D = C * sqrt (2)
        E = C + D

        y[1] = mathutils.Euler((-A, -A, 0.0), 'XYZ')
        print ("y1 =", y[1])
        
        b[2] = mathutils.Euler(((7.6/0.6)*A, (-6.4/0.6)*A, 0.0), 'XYZ')
        print ("b2 =", b[2])

        b[3] = mathutils.Euler(((7.471703/0.6)*A, (-19.577606/0.6)*A, 0.0), 'XYZ')
        print ("b3 =", b[3])

        y[2] = mathutils.Euler(((6.4/0.6)*A, (-7.6/0.6)*A, 0.0), 'XYZ')
        print ("y2 =", y[2])

        y[3] = mathutils.Euler(((5.7769/0.6)*A, (-19.488718/0.6)*A, 0.0), 'XYZ')
        print ("y3 =", y[3])

        y[4] = mathutils.Euler(((5.688129/0.6)*A, (-21.183546/0.6)*A, 0.0), 'XYZ')
        print ("y4 =", y[4])

        o[2] = mathutils.Euler(((8.094728/0.6)*A, (-7.688817/0.6)*A, 0.0), 'XYZ')
        print ("o2 =", o[2])

        o[3] = mathutils.Euler(((6.91248/0.6)*A, (-20.749912/0.6)*A, 0.0), 'XYZ')
        print ("o3 =", o[3])

    # Parent set disciple to master        
    def setParent(self, helicity, move, rig, disciple_loc, disciple_rot, disciple):

        bpy.ops.object.mode_set(mode='OBJECT')

        bpy.context.scene.frame_current = 0

        bpy.ops.object.select_all(action='DESELECT')
        rig.select_set(state=True)
        bpy.context.view_layer.objects.active = rig

        bpy.ops.object.editmode_toggle()

        parent_bone = 'y3y4' # choose the bone name which you want to be the parent

        rig.data.edit_bones.active = rig.data.edit_bones[parent_bone]

        bpy.ops.object.mode_set(mode='OBJECT')

        bpy.ops.object.select_all(action='DESELECT') #deselect all objects

        disciple.rig.select_set(state=True)

        rig.select_set(state=True)
        bpy.context.view_layer.objects.active = rig    #the active object will be the parent of all selected object

        bpy.ops.object.parent_set(type='BONE', keep_transform=True)

        bpy.ops.object.select_all(action='DESELECT') #deselect all objects

        # disciple position
        disciple.rig.location.x += disciple_loc[0]
        disciple.rig.location.y += disciple_loc[1]
        disciple.rig.location.z += disciple_loc[2]

        disciple.rig.rotation_euler = disciple_rot

    def configLink(self, A, J, helicity, rig, move, part):

        bpy.ops.object.mode_set(mode='OBJECT')
    
        Q = (0.18648+0.146446)*A
    #   Z = -Q*2
        Z = 0.0

        if part == 'right-upperhindlimb':
            obj_joint = bpy.data.objects["joint.gold.a2a1.upperhindlimb-right"].copy()
        else:
            obj_joint = bpy.data.objects["joint.gold.a2a1.upperhindlimb-left"].copy()
        
        obj_joint.location = (0.0, 0.0, -Q*3+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "a2a1.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.silver.001"].copy()
        obj_joint.location = (0.0, 0.0, +Q+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "y1a2.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.copper.001"].copy()
        obj_joint.location = (0.0, 0.0, +Q*3+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "a2o1.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.blue.001"].copy()
        obj_joint.location = (0.0, 0.0, -Q*2+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "a1b1.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)


        for n in range(1, J - 1):

            if n <= (J-2):

                # Pattern 2 of by
                obj_joint = bpy.data.objects["joint.green.001"].copy()
                obj_joint.location = (0.0, 0.0, -Q + Q*((n+1) % 2)*4 +Z)
                obj_joint.scale = (A, A, A)
                obj_joint.name = "b"+str(n)+"y"+str(n)+".mesh." + move + '.' + part +'.' + helicity
                bpy.data.collections['link'].objects.link(obj_joint)

                # Pattern 2 of yy
                obj_joint = bpy.data.objects["joint.gold.00"+str(1 + (n+1) % 2)].copy()
                obj_joint.location = (0.0, 0.0, +Q*(1 - (n % 2))*2+Z)
                obj_joint.scale = (A, A, A)
                obj_joint.name = "y"+str(n)+"y"+str(n+1)+".mesh." + move + '.' + part +'.' + helicity
                bpy.data.collections['link'].objects.link(obj_joint)


            if n <= (J-3):

                # Pattern 1 of ob
                obj_joint = bpy.data.objects["joint.blue.001"].copy()
                obj_joint.location = (0.0, 0.0, -Q*2 + Q*(n % 2)*6 +Z)
                obj_joint.scale = (A, A, A)
                obj_joint.name = "o"+str(n)+"b"+str(n+1)+".mesh." + move + '.' + part +'.' + helicity
                bpy.data.collections['link'].objects.link(obj_joint)

                # Pattern 2 of yo
                obj_joint = bpy.data.objects["joint.copper.001"].copy()
                obj_joint.location = (0.0, 0.0, -Q + Q*((n+1) % 2)*4 +Z)
                obj_joint.scale = (A, A, A)
                obj_joint.name = "y"+str(n+1)+"o"+str(n+1)+".mesh." + move + '.' + part +'.' + helicity
                bpy.data.collections['link'].objects.link(obj_joint)


        for ob in data.collections['link'].objects:
            if "mesh" in ob.name:
                ob.select_set(state = True, view_layer = None)

        bpy.ops.object.make_single_user(type='SELECTED_OBJECTS', object=True, obdata=True, material=True, animation=True)
        bpy.context.scene.cursor.location = (0.0, 0.0, 0.0)
        bpy.ops.object.origin_set(type='ORIGIN_CURSOR')


class LeftIlium(Formula):

    J = 5 #joint number

    # Overriding
    def __init__(self, P, A, move, part, helicity, start, end, disciple_loc, disciple_rot, disciple):

        global interval
        global frame_start
        global frame_end

        self.interval = interval
        self.frame_start = frame_start
        self.frame_end = frame_end

        # pivot factor
        self.P = P

        # scale factor
        self.A = A 

        # name
        self.move = move

        # element
        self.part = part

        # element helicity
        self.helicity = helicity

        self.start = start
        self.end = end

        # disciple position
        self.disciple_loc = disciple_loc
        self.disciple_rot = disciple_rot

        # disciple
        self.disciple = disciple

        # Create armature and object
        self.amt = bpy.data.armatures.new(move + '.' + part + '.' + helicity + '.data')
        self.rig = bpy.data.objects.new(move + '.' + part + '.' + helicity, self.amt)

        # Joints
        self.a = [0 for i in range(4)] # Joint α
        self.b = [0 for i in range(self.J)] # Joint β
        self.y = [0 for i in range(self.J)] # Joint γ
        self.o = [0 for i in range(self.J)] # Joint δ

        # Configuration Movement
        self.configMovement(self.P, self.A, self.J, self.a, self.b, self.y, self.o)

        # Construction Movement
        self.constructMovement(self.J, self.helicity, self.amt, self.rig, self.a, self.b, self.y, self.o)

        # Parent set disciple to master       
        self.setParent(self.helicity, self.move, self.rig, self.disciple_loc, self.disciple_rot, self.disciple)

        # Construction Rotation
        self.configRotation(self.rig, self.interval, self.frame_start, self.frame_end, self.start, self.end)

        # Configuration Linkage
        self.configLink(self.A*0.8, self.J, self.helicity, self.rig, self.move, self.part)

        # Construction Linkage
        self.constructLink(self.A*0.8, self.J, self.helicity, self.rig, self.move, self.part)

    # Overriding Configuration Movement
    def configMovement(self, P, A, J, a, b, y, o):

        a[1] = mathutils.Euler((P, A, 0.0), 'XYZ')
        print ("a1 =", a[1])

        a[2] = mathutils.Euler((A, -A, 0.0), 'XYZ')
        print ("a2 =", a[2])

        b[1] = mathutils.Euler((-A, A, 0.0), 'XYZ')
        print ("b1 =", b[1])

        o[1] = mathutils.Euler((A, A, 0.0), 'XYZ')
        print ("o1 =", o[1])

        B = A * 2 * sqrt (2)
        C = B + (B * sqrt (2))
        D = C * sqrt (2)
        E = C + D
        
        y[1] = mathutils.Euler((-A, -A, 0.0), 'XYZ')
        print ("y1 =", y[1])

        b[2] = mathutils.Euler(((A*3/0.512329)*A, (A/0.512329)*A, 0.0), 'XYZ')
        print ("b2 =", b[2])

        b[3] = mathutils.Euler(((-A/0.512329)*A, (-3/0.512329)*A, 0.0), 'XYZ')
        print ("b3 =", b[3])
        
        y[2] = mathutils.Euler(((A/0.512329)*A, (-A/0.512329)*A, 0.0), 'XYZ')
        print ("y2 =", y[2])

        y[3] = mathutils.Euler(((A/0.512329)*A, (-3/0.512329)*A, 0.0), 'XYZ')
        print ("y3 =", y[3])

        o[2] = mathutils.Euler(((-A/0.512329)*A, (-A/0.512329)*A, 0.0), 'XYZ')
        print ("o2 =", o[2])
        
        o[3] = mathutils.Euler(((A/0.512329)*A, (-4.03054/0.512329)*A, 0.0), 'XYZ')
        print ("o3 =", o[3])
        
        y[4] = mathutils.Euler(((A*3/0.512329)*A, (-3/0.512329)*A, 0.0), 'XYZ')
        print ("y4 =", y[4])

    # Parent set disciple to master        
    def setParent(self, helicity, move, rig, disciple_loc, disciple_rot, disciple):

        bpy.ops.object.mode_set(mode='OBJECT')

        bpy.context.scene.frame_current = 0

        bpy.ops.object.select_all(action='DESELECT')
        rig.select_set(state=True)
        bpy.context.view_layer.objects.active = rig

        bpy.ops.object.editmode_toggle()

        parent_bone = 'b3y3' # choose the bone name which you want to be the parent

        rig.data.edit_bones.active = rig.data.edit_bones[parent_bone]

        bpy.ops.object.mode_set(mode='OBJECT')

        bpy.ops.object.select_all(action='DESELECT') #deselect all objects

        disciple.rig.select_set(state=True)

        rig.select_set(state=True)
        bpy.context.view_layer.objects.active = rig    #the active object will be the parent of all selected object

        bpy.ops.object.parent_set(type='BONE', keep_transform=True)

        bpy.ops.object.select_all(action='DESELECT') #deselect all objects

        # disciple position
        disciple.rig.location.x += disciple_loc[0]
        disciple.rig.location.y += disciple_loc[1]
        disciple.rig.location.z += disciple_loc[2]

        disciple.rig.rotation_euler = disciple_rot

    def configLink(self, A, J, helicity, rig, move, part):

        bpy.ops.object.mode_set(mode='OBJECT')
    
        Q = (0.18648+0.146446)*A
    #   Z = -Q*2
        Z = 0.0

        obj_joint = bpy.data.objects["joint.gold.000"].copy()
        obj_joint.location = (0.0, 0.0, -Q*0+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "a2a1.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.silver.002"].copy()
        obj_joint.location = (0.0, 0.0, +Q*4+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "y1a2.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.copper.001"].copy()
        obj_joint.location = (0.0, 0.0, +Q*6+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "a2o1.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.blue.001"].copy()
        obj_joint.location = (0.0, 0.0, +Q*1+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "a1b1.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)


        for n in range(1, J - 1):

            if n <= (J-2):

                if n == 1:
                    
                    obj_joint = bpy.data.objects["joint.green.002"].copy()
                    obj_joint.location = (0.0, 0.0, +Q*2 + Q*((n+1) % 2)*4 +Z)
                    obj_joint.scale = (A, A, A)
                    obj_joint.name = "b"+str(n)+"y"+str(n)+".mesh." + move + '.' + part +'.' + helicity
                    bpy.data.collections['link'].objects.link(obj_joint)                    

                else:
                    # Pattern 2 of by
                    obj_joint = bpy.data.objects["joint.green.001"].copy()
                    obj_joint.location = (0.0, 0.0, -Q + Q*((n+1) % 2)*4 +Z)
                    obj_joint.scale = (A, A, A)
                    obj_joint.name = "b"+str(n)+"y"+str(n)+".mesh." + move + '.' + part +'.' + helicity
                    bpy.data.collections['link'].objects.link(obj_joint)

            if n <= (J-3):

                # Pattern 2 of yy
                obj_joint = bpy.data.objects["joint.gold.00"+str(1 + (n+1) % 2)].copy()
                obj_joint.location = (0.0, 0.0, +Q*(1 - (n % 2))*2+Z)
                obj_joint.scale = (A, A, A)
                obj_joint.name = "y"+str(n)+"y"+str(n+1)+".mesh." + move + '.' + part +'.' + helicity
                bpy.data.collections['link'].objects.link(obj_joint)

                if n == 1:
                    # Pattern 1 of ob
                    obj_joint = bpy.data.objects["joint.blue.002"].copy()
                    obj_joint.location = (0.0, 0.0, +Q*1 + Q*(n % 2)*6 +Z)
                    obj_joint.scale = (A, A, A)
                    obj_joint.name = "o"+str(n)+"b"+str(n+1)+".mesh." + move + '.' + part +'.' + helicity
                    bpy.data.collections['link'].objects.link(obj_joint)

                else:
                    # Pattern 1 of ob
                    obj_joint = bpy.data.objects["joint.blue.001"].copy()
                    obj_joint.location = (0.0, 0.0, -Q*2 + Q*(n % 2)*6 +Z)
                    obj_joint.scale = (A, A, A)
                    obj_joint.name = "o"+str(n)+"b"+str(n+1)+".mesh." + move + '.' + part +'.' + helicity
                    bpy.data.collections['link'].objects.link(obj_joint)

                # Pattern 2 of yo
                obj_joint = bpy.data.objects["joint.copper.001"].copy()
                obj_joint.location = (0.0, 0.0, -Q + Q*((n+1) % 2)*4 +Z)
                obj_joint.scale = (A, A, A)
                obj_joint.name = "y"+str(n+1)+"o"+str(n+1)+".mesh." + move + '.' + part +'.' + helicity
                bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.gold.spine.y3y4"].copy()
        obj_joint.location = (0.0, 0.0, +Q*(1 - (3 % 2))*2+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "y3y4.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)


        for ob in data.collections['link'].objects:
            if "mesh" in ob.name:
                ob.select_set(state = True, view_layer = None)

        bpy.ops.object.make_single_user(type='SELECTED_OBJECTS', object=True, obdata=True, material=True, animation=True)
        bpy.context.scene.cursor.location = (0.0, 0.0, 0.0)
        bpy.ops.object.origin_set(type='ORIGIN_CURSOR')


class RightIlium(LeftIlium):

    J = 5 #joint number

    # Overriding
    def __init__(self, P, A, move, part, helicity, start, end,
        disciple_loc, disciple_rot, disciple, disciple2_loc, disciple2_rot, disciple2):

        global interval
        global frame_start
        global frame_end

        self.interval = interval
        self.frame_start = frame_start
        self.frame_end = frame_end

        # pivot factor
        self.P = P

        # scale factor
        self.A = A 

        # name
        self.move = move

        # element
        self.part = part

        # element helicity
        self.helicity = helicity

        self.start = start
        self.end = end

        # disciple position
        self.disciple_loc = disciple_loc
        self.disciple_rot = disciple_rot

        # disciple
        self.disciple = disciple
        
        # disciple position
        self.disciple2_loc = disciple2_loc
        self.disciple2_rot = disciple2_rot

        # disciple
        self.disciple2 = disciple2

        # Create armature and object
        self.amt = bpy.data.armatures.new(move + '.' + part + '.' + helicity + '.data')
        self.rig = bpy.data.objects.new(move + '.' + part + '.' + helicity, self.amt)

        # Joints
        self.a = [0 for i in range(4)] # Joint α
        self.b = [0 for i in range(self.J)] # Joint β
        self.y = [0 for i in range(self.J)] # Joint γ
        self.o = [0 for i in range(self.J)] # Joint δ

        # Configuration Movement
        self.configMovement(self.P, self.A, self.J, self.a, self.b, self.y, self.o)

        # Construction Movement
        self.constructMovement(self.J, self.helicity, self.amt, self.rig, self.a, self.b, self.y, self.o)

        # Parent set disciple to master       
        self.setParent(self.helicity, self.move, self.rig, self.disciple_loc, self.disciple_rot,
            self.disciple, self.disciple2_loc, self.disciple2_rot, self.disciple2)

        # Construction Rotation
        self.configRotation(self.rig, self.interval, self.frame_start, self.frame_end, self.start, self.end)

        # Configuration Linkage
        self.configLink(self.A*0.8, self.J, self.helicity, self.rig, self.move, self.part)

        # Construction Linkage
        self.constructLink(self.A*0.8, self.J, self.helicity, self.rig, self.move, self.part)

    # Overriding Configuration Movement
    def configMovement(self, P, A, J, a, b, y, o):

        a[1] = mathutils.Euler((P, A, 0.0), 'XYZ')
        print ("a1 =", a[1])

        a[2] = mathutils.Euler((A, -A, 0.0), 'XYZ')
        print ("a2 =", a[2])

        b[1] = mathutils.Euler((-A, A, 0.0), 'XYZ')
        print ("b1 =", b[1])

        o[1] = mathutils.Euler((A, A, 0.0), 'XYZ')
        print ("o1 =", o[1])

        B = A * 2 * sqrt (2)
        C = B + (B * sqrt (2))
        D = C * sqrt (2)
        E = C + D
        
        y[1] = mathutils.Euler((-A, -A, 0.0), 'XYZ')
        print ("y1 =", y[1])

        b[2] = mathutils.Euler(((A*3/0.512329)*A, (A/0.512329)*A, 0.0), 'XYZ')
        print ("b2 =", b[2])

        b[3] = mathutils.Euler(((-A/0.512329)*A, (1.97543/0.512329)*A, 0.0), 'XYZ')
        print ("b3 =", b[3])
        
        y[2] = mathutils.Euler(((A/0.512329)*A, (-A/0.512329)*A, 0.0), 'XYZ')
        print ("y2 =", y[2])

        y[3] = mathutils.Euler(((A/0.512329)*A, (1.97543/0.512329)*A, 0.0), 'XYZ')
        print ("y3 =", y[3])

        o[2] = mathutils.Euler(((-A/0.512329)*A, (-A/0.512329)*A, 0.0), 'XYZ')
        print ("o2 =", o[2])
        
        o[3] = mathutils.Euler(((A/0.512329)*A, (3/0.512329)*A, 0.0), 'XYZ')
        print ("o3 =", o[3])
        
        y[4] = mathutils.Euler(((A*3/0.512329)*A, (1.97543/0.512329)*A, 0.0), 'XYZ')
        print ("y4 =", y[4])

    # Parent set disciple to master
    def setParent(self, helicity, move, rig, disciple_loc, disciple_rot, disciple, 
            disciple2_loc, disciple2_rot, disciple2):

        bpy.ops.object.mode_set(mode='OBJECT')

        bpy.context.scene.frame_current = 0

        bpy.ops.object.select_all(action='DESELECT')
        rig.select_set(state=True)
        bpy.context.view_layer.objects.active = rig

        bpy.ops.object.editmode_toggle()

        parent_bone = 'y1y2' # choose the bone name which you want to be the parent

        rig.data.edit_bones.active = rig.data.edit_bones[parent_bone]

        bpy.ops.object.mode_set(mode='OBJECT')

        bpy.ops.object.select_all(action='DESELECT') #deselect all objects

        #disciple
        disciple.rig.select_set(state=True)

        rig.select_set(state=True)
        bpy.context.view_layer.objects.active = rig    #the active object will be the parent of all selected object

        bpy.ops.object.parent_set(type='BONE', keep_transform=True)

        bpy.ops.object.select_all(action='DESELECT') #deselect all objects

        # disciple position
        disciple.rig.location.x += disciple_loc[0]
        disciple.rig.location.y += disciple_loc[1]
        disciple.rig.location.z += disciple_loc[2]

        disciple.rig.rotation_euler = disciple_rot
        

        bpy.ops.object.mode_set(mode='OBJECT')

        bpy.context.scene.frame_current = 0

        bpy.ops.object.select_all(action='DESELECT')
        rig.select_set(state=True)
        bpy.context.view_layer.objects.active = rig

        bpy.ops.object.editmode_toggle()

        parent_bone = 'b3y3' # choose the bone name which you want to be the parent

        rig.data.edit_bones.active = rig.data.edit_bones[parent_bone]

        bpy.ops.object.mode_set(mode='OBJECT')

        bpy.ops.object.select_all(action='DESELECT') #deselect all objects

        #disciple2
        disciple2.rig.select_set(state=True)

        rig.select_set(state=True)
        bpy.context.view_layer.objects.active = rig    #the active object will be the parent of all selected object

        bpy.ops.object.parent_set(type='BONE', keep_transform=True)

        bpy.ops.object.select_all(action='DESELECT') #deselect all objects

        # disciple2 position
        disciple2.rig.location.x += disciple2_loc[0]
        disciple2.rig.location.y += disciple2_loc[1]
        disciple2.rig.location.z += disciple2_loc[2]

        disciple2.rig.rotation_euler = disciple2_rot
    
        
class Tail(Formula):

    J = 6 #joint number

    # Overriding
    def __init__(self, P, A, move, part, helicity, start, end):

        global interval
        global frame_start
        global frame_end

        self.interval = interval
        self.frame_start = frame_start
        self.frame_end = frame_end

        # pivot factor
        self.P = P

        # scale factor
        self.A = A 

        # name
        self.move = move

        # element
        self.part = part

        # element helicity
        self.helicity = helicity

        self.start = start
        self.end = end

        # Create armature and object
        self.amt = bpy.data.armatures.new(move + '.' + part + '.' + helicity + '.data')
        self.rig = bpy.data.objects.new(move + '.' + part + '.' + helicity, self.amt)

        # Joints
        self.a = [0 for i in range(4)] # Joint α
        self.b = [0 for i in range(self.J)] # Joint β
        self.y = [0 for i in range(self.J)] # Joint γ
        self.o = [0 for i in range(self.J)] # Joint δ

        # Configuration Movement
        self.configMovement(self.P, self.A, self.J, self.a, self.b, self.y, self.o)

        # Construction Movement
        self.constructMovement(self.J, self.helicity, self.amt, self.rig, self.a, self.b, self.y, self.o)

        # Construction Rotation
        self.configRotation(self.rig, self.interval, self.frame_start, self.frame_end, self.start, self.end)

        # Configuration Linkage
        self.configLink(0.8*self.A, self.J, self.helicity, self.rig, self.move, self.part)

        # Construction Linkage
        self.constructLink(0.8*self.A, self.J, self.helicity, self.rig, self.move, self.part)

    # Overriding Configuration Movement
    def configMovement(self, P, A, J, a, b, y, o):

        a[1] = mathutils.Euler((P, A, 0.0), 'XYZ')
        print ("a1 =", a[1])

        a[2] = mathutils.Euler((A, -A, 0.0), 'XYZ')
        print ("a2 =", a[2])

        b[1] = mathutils.Euler((-A, A, 0.0), 'XYZ')
        print ("b1 =", b[1])

        o[1] = mathutils.Euler((A, A, 0.0), 'XYZ')
        print ("o1 =", o[1])

        B = A * 2 * sqrt (2)
        C = B + (B * sqrt (2))
        D = C * sqrt (2)
        E = C + D

        y[1] = mathutils.Euler((-A, -A, 0.0), 'XYZ')
        print ("y1 =", y[1])
        
        b[2] = mathutils.Euler(((4.08/0.7)*A, (-2.68/0.7)*A, 0.0), 'XYZ')
        print ("b2 =", b[2])

        b[3] = mathutils.Euler(((2.520382/0.7)*A, (-7.734981/0.7)*A, 0.0), 'XYZ')
        print ("b3 =", b[3])

        b[4] = mathutils.Euler(((4.650852/0.7)*A, (-10.086805/0.7)*A, 0.0), 'XYZ')
        print ("b4 =", b[4])

        y[2] = mathutils.Euler(((2.68/0.7)*A, (-4.08/0.7)*A, 0.0), 'XYZ')
        print ("y2 =", y[2])

        y[3] = mathutils.Euler(((4.314873/0.7)*A, (-8.571764/0.7)*A, 0.0), 'XYZ')
        print ("y3 =", y[3])

        y[4] = mathutils.Euler(((4.065916/0.7)*A, (-9.98368/0.7)*A, 0.0), 'XYZ')
        print ("y4 =", y[4])

        y[5] = mathutils.Euler(((3.816914/0.7)*A, (-11.395846/0.7)*A, 0.0), 'XYZ')
        print ("y5 =", y[5])

        o[2] = mathutils.Euler(((4.5405/0.7)*A, (-3.402836/0.7)*A, 0.0), 'XYZ')
        print ("o2 =", o[2])

        o[3] = mathutils.Euler(((4.899491/0.7)*A, (-8.674883/0.7)*A, 0.0), 'XYZ')
        print ("o3 =", o[3])
        
        o[4] = b[4]
        print ("o4 =", o[4])

    def configLink(self, A, J, helicity, rig, move, part):

        bpy.ops.object.mode_set(mode='OBJECT')
    
        Q = (0.18648+0.146446)*A
    #   Z = -Q*2
        Z = 0.0

        if part == 'tail':
            obj_joint = bpy.data.objects["joint.gold.a2a1.tail"].copy()
        else:
            obj_joint = bpy.data.objects["joint.gold.a2a1.tail"].copy()
        
        obj_joint.location = (0.0, 0.0, -Q*3+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "a2a1.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.silver.001"].copy()
        obj_joint.location = (0.0, 0.0, +Q+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "y1a2.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.copper.001"].copy()
        obj_joint.location = (0.0, 0.0, +Q*3+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "a2o1.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.blue.001"].copy()
        obj_joint.location = (0.0, 0.0, -Q*2+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "a1b1.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)


        for n in range(1, J - 1):

            if n <= (J-2):

                # Pattern 2 of by
                obj_joint = bpy.data.objects["joint.green.001"].copy()
                obj_joint.location = (0.0, 0.0, -Q + Q*((n+1) % 2)*4 +Z)
                obj_joint.scale = (A, A, A)
                obj_joint.name = "b"+str(n)+"y"+str(n)+".mesh." + move + '.' + part +'.' + helicity
                bpy.data.collections['link'].objects.link(obj_joint)

                # Pattern 2 of yy
                obj_joint = bpy.data.objects["joint.gold.00"+str(1 + (n+1) % 2)].copy()
                obj_joint.location = (0.0, 0.0, +Q*(1 - (n % 2))*2+Z)
                obj_joint.scale = (A, A, A)
                obj_joint.name = "y"+str(n)+"y"+str(n+1)+".mesh." + move + '.' + part +'.' + helicity
                bpy.data.collections['link'].objects.link(obj_joint)


            if n <= (J-3):

                # Pattern 1 of ob
                obj_joint = bpy.data.objects["joint.blue.001"].copy()
                obj_joint.location = (0.0, 0.0, -Q*2 + Q*(n % 2)*6 +Z)
                obj_joint.scale = (A, A, A)
                obj_joint.name = "o"+str(n)+"b"+str(n+1)+".mesh." + move + '.' + part +'.' + helicity
                bpy.data.collections['link'].objects.link(obj_joint)

                # Pattern 2 of yo
                obj_joint = bpy.data.objects["joint.copper.001"].copy()
                obj_joint.location = (0.0, 0.0, -Q + Q*((n+1) % 2)*4 +Z)
                obj_joint.scale = (A, A, A)
                obj_joint.name = "y"+str(n+1)+"o"+str(n+1)+".mesh." + move + '.' + part +'.' + helicity
                bpy.data.collections['link'].objects.link(obj_joint)


        for ob in data.collections['link'].objects:
            if "mesh" in ob.name:
                ob.select_set(state = True, view_layer = None)

        bpy.ops.object.make_single_user(type='SELECTED_OBJECTS', object=True, obdata=True, material=True, animation=True)
        bpy.context.scene.cursor.location = (0.0, 0.0, 0.0)
        bpy.ops.object.origin_set(type='ORIGIN_CURSOR')


class Sacrum(Formula):

    J = 3 #joint number

    # Overriding
    def __init__(self, P, A, move, part, helicity, start, end, 
        disciple_loc, disciple_rot, disciple):

        global interval
        global frame_start
        global frame_end

        self.interval = interval
        self.frame_start = frame_start
        self.frame_end = frame_end

        # pivot factor
        self.P = P

        # scale factor
        self.A = A 

        # name
        self.move = move

        # element
        self.part = part

        # element helicity
        self.helicity = helicity

        self.start = start
        self.end = end

        # disciple position
        self.disciple_loc = disciple_loc
        self.disciple_rot = disciple_rot

        # disciple
        self.disciple = disciple

        # Create armature and object
        self.amt = bpy.data.armatures.new(move + '.' + part + '.' + helicity + '.data')
        self.rig = bpy.data.objects.new(move + '.' + part + '.' + helicity, self.amt)

        # Joints
        self.a = [0 for i in range(self.J)] # Joint α
        self.b = [0 for i in range(self.J)] # Joint β
        self.y = [0 for i in range(self.J)] # Joint γ
        self.o = [0 for i in range(self.J)] # Joint δ

        # Configuration Movement
        self.configMovement(self.P, self.A, self.J, self.a, self.b, self.y, self.o)

        # Construction Movement
        self.constructMovement(self.J, self.helicity, self.amt, self.rig, self.a, self.b, self.y, self.o)

        # Parent set disciple to master
        self.setParent(self.helicity, self.move, self.rig,
            self.disciple_loc, self.disciple_rot, self.disciple)

        # Construction Rotation
        self.configRotation(self.rig, self.interval, self.frame_start, self.frame_end, self.start, self.end)

        # Configuration Linkage
        self.configLink(self.A, self.J, self.helicity, self.rig, self.move, self.part)

        # Construction Linkage
        self.constructLink(self.A, self.J, self.helicity, self.rig, self.move, self.part)

    # Overriding Configuration Movement
    def configMovement(self, P, A, J, a, b, y, o):

        a[1] = mathutils.Euler((P, A, 0.0), 'XYZ')
        print ("a1 =", a[1])

        a[2] = mathutils.Euler((A, -A, 0.0), 'XYZ')
        print ("a2 =", a[2])

        b[1] = mathutils.Euler((-A, A, 0.0), 'XYZ')
        print ("b1 =", b[1])

        B = A * 2 * sqrt (2)
        C = B + (B * sqrt (2))
        D = C * sqrt (2)
        E = C + D

        y[1] = mathutils.Euler((-A, -A, 0.0), 'XYZ')
        print ("y1 =", y[1])
        
        y[2] = mathutils.Euler((-A, -(0.173028/0.431828)*A, 0.0), 'XYZ')
        print ("y2 =", y[2])

        o[1] = mathutils.Euler(((-0.77453/0.431828)*A, -A, 0.0), 'XYZ')
        print ("o1 =", o[1])

    def constructMovement(self, J, helicity, amt, rig, a, b, y, o):

        # Linkages
        aa = [[0 for i in range(4)] for j in range(4)] # Link α(i) - α(j)
        ab = [[0 for i in range(4)] for j in range(4)] # Link α(i) - β(j)
        ya = [[0 for i in range(4)] for j in range(4)] # Link γ(i) - α(j)
        yy = [[0 for i in range(self.J)] for j in range(self.J)] # Link γ(i) - γ(j)
        by = [[0 for i in range(self.J)] for j in range(self.J)] # Link β(i) - γ(j)
        yo = [[0 for i in range(self.J)] for j in range(self.J)] # Link γ(i) - δ(j)

        rig.location = mathutils.Euler((0.0, 0.0, 0.0), 'XYZ')
        rig.show_in_front = True
        amt.show_names = True
        amt.display_type = 'STICK'
#        amt.display_type = 'BBONE'

        # Link object to scene

        bpy.data.collections['movement'].objects.link(rig)
        bpy.context.view_layer.objects.active = rig
        bpy.context.view_layer.update()

        # Edit
        bpy.ops.object.editmode_toggle()

        # Construction Linkage
        aa[2][1] = amt.edit_bones.new('a2a1')
        aa[2][1].head = a[2]
        aa[2][1].tail = a[1]
        
        ab[1][1] = amt.edit_bones.new('a1b1')
        ab[1][1].head = a[1]
        ab[1][1].tail = b[1]
        ab[1][1].parent = aa[2][1]
 
        by[1][1] = amt.edit_bones.new('b1y1')
        by[1][1].head = b[1]
        by[1][1].tail = y[1]
        by[1][1].parent = ab[1][1]
        by[1][1].use_inherit_rotation = False

        ya[1][2] = amt.edit_bones.new('y1a2')
        ya[1][2].head = y[1]
        ya[1][2].tail = a[2]
        ya[1][2].parent = by[1][1]

        yo[1][1] = amt.edit_bones.new('y1o1')
        yo[1][1].head = y[1]
        yo[1][1].tail = o[1]
        yo[1][1].parent = ya[1][2]
   
        yy[1][2] = amt.edit_bones.new('y1y2')
        yy[1][2].head = y[1]
        yy[1][2].tail = y[2]
        yy[1][2].parent = by[1][1]

        # all bones select

        # Bone constraints. Armature must be in pose mode.
        bpy.ops.object.mode_set(mode='POSE')

        bpy.ops.pose.select_all(action="SELECT")

        # Edit
        bpy.ops.object.editmode_toggle()

        if helicity == 'right':
            bpy.ops.armature.calculate_roll(type='GLOBAL_POS_Z')
        else:
            bpy.ops.armature.calculate_roll(type='GLOBAL_NEG_Z')
 
        # IK constraint
        cns = rig.pose.bones['y1a2'].constraints.new('IK')
        cns.name = 'Ik'
        cns.target = rig
        cns.subtarget = 'a2a1'
        cns.chain_count = 2
        cns.use_stretch = False

        bpy.ops.object.mode_set(mode='OBJECT')

    # Parent set disciple to master
    def setParent(self, helicity, move, rig, disciple_loc, disciple_rot, disciple):

        bpy.ops.object.mode_set(mode='OBJECT')

        bpy.context.scene.frame_current = 0

        bpy.ops.object.select_all(action='DESELECT')
        rig.select_set(state=True)
        bpy.context.view_layer.objects.active = rig

        bpy.ops.object.editmode_toggle()

        parent_bone = 'y1o1' # choose the bone name which you want to be the parent

        rig.data.edit_bones.active = rig.data.edit_bones[parent_bone]

        bpy.ops.object.mode_set(mode='OBJECT')

        bpy.ops.object.select_all(action='DESELECT') #deselect all objects

        disciple.rig.select_set(state=True)

        rig.select_set(state=True)
        bpy.context.view_layer.objects.active = rig    #the active object will be the parent of all selected object

        bpy.ops.object.parent_set(type='BONE', keep_transform=True)

        bpy.ops.object.select_all(action='DESELECT') #deselect all objects

        # disciple position
        disciple.rig.location.x += disciple_loc[0]
        disciple.rig.location.y += disciple_loc[1]
        disciple.rig.location.z += disciple_loc[2]

        disciple.rig.rotation_euler = disciple_rot

    def configLink(self, A, J, helicity, rig, move, part):

        bpy.ops.object.mode_set(mode='OBJECT')
    
        Q = (0.18648+0.146446)*A
    #   Z = -Q*2
        Z = 0.0

        obj_joint = bpy.data.objects["joint.gold.000"].copy()
        obj_joint.location = (0.0, 0.0, -Q*3+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "a2a1.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.silver.001"].copy()
        obj_joint.location = (0.0, 0.0, +Q+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "y1a2.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.copper.y1o1.sacrum.B"].copy()
        obj_joint.location = (0.0, 0.0, +Q*3+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "y1o1.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.blue.001"].copy()
        obj_joint.location = (0.0, 0.0, -Q*2+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "a1b1.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        n = 1

        # Pattern 2 of by
        obj_joint = bpy.data.objects["joint.green.001"].copy()
        obj_joint.location = (0.0, 0.0, -Q + Q*((n+1) % 2)*4 +Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "b"+str(n)+"y"+str(n)+".mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        # Pattern 2 of yy
        obj_joint = bpy.data.objects["joint.gold.00"+str(1 + (n+1) % 2)].copy()
        obj_joint.location = (0.0, 0.0, +Q*(1 - (n % 2))*2+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "y"+str(n)+"y"+str(n+1)+".mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        for ob in data.collections['link'].objects:
            if "mesh" in ob.name:
                ob.select_set(state = True, view_layer = None)

        bpy.ops.object.make_single_user(type='SELECTED_OBJECTS', object=True, obdata=True, material=True, animation=True)
        bpy.context.scene.cursor.location = (0.0, 0.0, 0.0)
        bpy.ops.object.origin_set(type='ORIGIN_CURSOR')


def formula():

# pivot factor
    P = 0

# scale factor
    A = 1
    
# joint number
    J = 6
    
# name
    move = 'formula'

# element
    part = 'universe'

# left or right
    helicity = 'left'

    start = 0
    end = start+360

    formula = Formula(P, A, J, move, part, helicity, start, end)


def lowerforelimbs():

# scale factor
    A = 0.35

# pivot factor
    P = ((0.75*-0.35)/0.35)*A
    
# name
    move = 'equestrianism-pace'

# element
    part = 'right-lowerforelimb'

# left or right
    helicity = 'right'

    start = -85
    end = start-720

    global lowerforelimb_right
    lowerforelimb_right = LowerForelimb(P, A, move, part, helicity, start, end)

# element
    part = 'left-lowerforelimb'

# left or right
    helicity = 'left'
    
    start =  -85
    end = start+720

    global lowerforelimb_left
    lowerforelimb_left = LowerForelimb(P, A, move, part, helicity, start, end)

    
def upperforelimbs():

# scale factor
    A = 0.6

# pivot factor
    P = 0.0
    
# name
    move = 'equestrianism-pace'

# element
    part = 'right-upperforelimb'

# left or right
    helicity = 'right'

    start = 90
    end = start-720

    global lowerforelimb_right
    
    lowerforelimb = lowerforelimb_right

    lowerforelimb_loc = ((9.657187/0.6)*A, (-20.120846/0.6)*A, (-0.031213/0.6)*A)
    lowerforelimb_rot = mathutils.Euler((math.radians(-180), math.radians(180), math.radians(185)), 'XYZ')

    global upperforelimb_right
    upperforelimb_right = UpperForelimb(P, A, move, part, helicity, start, end,
        lowerforelimb_loc, lowerforelimb_rot, lowerforelimb)

# element
    part = 'left-upperforelimb'

# left or right
    helicity = 'left'
    
    start =  90
    end = start+720

    global lowerforelimb_left
    
    lowerforelimb = lowerforelimb_left

    lowerforelimb_loc = ((9.657187/0.6)*A, (-20.120846/0.6)*A, (-0.031213/0.6)*A)
    lowerforelimb_rot = mathutils.Euler((math.radians(-180), math.radians(180), math.radians(185)), 'XYZ')

    global upperforelimb_left
    upperforelimb_left = UpperForelimb(P, A, move, part, helicity, start, end,
        lowerforelimb_loc, lowerforelimb_rot, lowerforelimb)


def shoulder():

    start = 44
    end = start+720
    
# name
    move = 'equestrianism-pace'
    
# scale factor
    A = 0.512329

# pivot factor
    P = (-0.467885/0.512329)*A

# element
    part = 'right-shoulder'

# left or right
    helicity = 'left'

    global upperforelimb_right
    upperforelimb = upperforelimb_right

    upperforelimb_loc = ((1.841208/0.512329)*A, (-4.782617/0.512329)*A, (-1.980514/0.512329)*A)
    upperforelimb_rot = mathutils.Euler((math.radians(-269.253), math.radians(-257.073), math.radians(-538.019)), 'XYZ')

    global shoulder_right
    shoulder_right = RightShoulder(P, A, move, part, helicity, start, end,
        upperforelimb_loc, upperforelimb_rot, upperforelimb)
 
    start = 44
    end = start+720

# element
    part = 'left-shoulder'

    global neck

    neck_loc = ((1.518864/0.512329)*A, (-1.409492/0.512329)*A, (0.676093/0.512329)*A)
    neck_rot = mathutils.Euler((math.radians(-720), math.radians(180), math.radians(180)), 'XYZ')

    global upperforelimb_left
    upperforelimb = upperforelimb_left

    upperforelimb_loc = ((2.049464/0.512329)*A, (2.827685/0.512329)*A, (-2.198156/0.512329)*A)
    upperforelimb_rot = mathutils.Euler((math.radians(-89.2696), math.radians(76.9094), math.radians(-1076.87)), 'XYZ')

    global shoulder_left
    shoulder_left = LeftShoulder(P, A, move, part, helicity, start, end,
        neck_loc, neck_rot, neck, upperforelimb_loc, upperforelimb_rot, upperforelimb)
    

def head():

# scale factor
    A = 0.476741

# pivot factor
    P = (-0.327763/0.476741)*A
    
# name
    move = 'equestrianism-pace'

# element
    part = 'head'

# left or right
    helicity = 'right'

    start = -90
    end = start-720*2

    global head
    head = Head(P, A, move, part, helicity, start, end)
    

def neck():
    
# scale factor
    A = 0.953482
    
# pivot factor
    P = 0

# name
    move = 'equestrianism-pace'

# neck element
    part = 'neck'

# helicity
    helicity = 'left'

    start = 0
    end = start+0

    head_loc = ((-3.369717/0.953482)*A, (-0.875949/0.953482)*A, (-0.790696/0.953482)*A)
    head_rot = mathutils.Euler((math.radians(270), math.radians(-172.554), math.radians(0)), 'XYZ')

    global head
    
    global neck
    neck = Neck(P, A, move, part, helicity, start, end, head_loc, head_rot, head)
    
    
def lowerhindlimbs():

# scale factor
    A = 0.35

# pivot factor
    P = ((0.75*-0.35)/0.35)*A
    
# name
    move = 'equestrianism-pace'

# element
    part = 'right-lowerhindlimb'

# left or right
    helicity = 'left'

    start = 64
    end = start+720

    global lowerhindlimb_right
    lowerhindlimb_right = LowerHindlimb(P, A, move, part, helicity, start, end)

# element
    part = 'left-lowerhindlimb'

# left or right
    helicity = 'right'
    
    start = -244
    end = start-720

    global lowerhindlimb_left
    lowerhindlimb_left = LowerHindlimb(P, A, move, part, helicity, start, end)
    
    
def upperhindlimbs():

# scale factor
    A = 0.6

# pivot factor
    P = 0.0
    
# name
    move = 'equestrianism-pace'

# element
    part = 'right-upperhindlimb'

# left or right
    helicity = 'left'

    start = -135
    end = start-720

    global lowerhindlimb_right
    
    lowerhindlimb = lowerhindlimb_right

    lowerhindlimb_loc = ((6.346961/0.6)*A, (-20.121071/0.6)*A, 0.0)
    lowerhindlimb_rot = mathutils.Euler((math.radians(-180), math.radians(180), math.radians(192)), 'XYZ')

    global upperhindlimb_right
    upperhindlimb_right = UpperHindlimb(P, A, move, part, helicity, start, end,
        lowerhindlimb_loc, lowerhindlimb_rot, lowerhindlimb)

# element
    part = 'left-upperhindlimb'

# left or right
    helicity = 'right'

    start = -45
    end = start+720

    global lowerhindlimb_left
    
    lowerhindlimb = lowerhindlimb_left

    lowerhindlimb_loc = ((6.346961/0.6)*A, (-20.121071/0.6)*A, 0.0)
    lowerhindlimb_rot = mathutils.Euler((math.radians(-180), math.radians(180), math.radians(192)), 'XYZ')

    global upperhindlimb_left
    upperhindlimb_left = UpperHindlimb(P, A, move, part, helicity, start, end,
        lowerhindlimb_loc, lowerhindlimb_rot, lowerhindlimb)


def ilium():

    start = 179
    end = start+720
    
# name
    move = 'equestrianism-pace'
    
# scale factor
    A = 0.512329

# pivot factor
    P = (-0.467885/0.512329)*A

# element
    part = 'left-ilium'

# left or right
    helicity = 'left'

    global upperhindlimb_left
    
    upperhindlimb = upperhindlimb_left

    upperhindlimb_loc = ((3.293583/0.512329)*A, (-4.316476/0.512329)*A, (1.055012/0.512329)*A)
    upperhindlimb_rot = mathutils.Euler((math.radians(79.4694), math.radians(81.7266), math.radians(892.052)), 'XYZ')

    global ilium_left
    ilium_left = LeftIlium(P, A, move, part, helicity, start, end,
        upperhindlimb_loc, upperhindlimb_rot, upperhindlimb)

    start = 179
    end = start+720

# element
    part = 'right-ilium'

    global tail

    tail_loc = ((1.095053/0.512329)*A, (-0.236876/0.512329)*A, (7.257094/0.512329)*A)
    tail_rot = mathutils.Euler((math.radians(90), math.radians(252.044), math.radians(0)), 'XYZ')

    global upperhindlimb_right

    upperhindlimb = upperhindlimb_right

    upperhindlimb_loc = ((3.028501/0.512329)*A, (3.383841/0.512329)*A, (1.280923/0.512329)*A)
    upperhindlimb_rot = mathutils.Euler((math.radians(-270.286), math.radians(81.7909), math.radians(182.527)), 'XYZ')

    global ilium_right
    ilium_right = RightIlium(P, A, move, part, helicity, start, end,
        tail_loc, tail_rot, tail, upperhindlimb_loc, upperhindlimb_rot, upperhindlimb)


def tail():

# scale factor
    A = 0.7

# pivot factor
    P = (-0.437499/0.7)*A
    
# name
    move = 'equestrianism-pace'

# element
    part = 'tail'

# left or right
    helicity = 'right'

    start = 0
    end = start+720*2

    global tail
    tail = Tail(P, A, move, part, helicity, start, end)


def costa():

# scale factor
    A = 1.28082

# pivot factor
    P = (-1.20397/1.28082)*A

# name
    move = 'front-crawl'

# element
    part = 'costa'

# left or right
    helicity = 'left'

    start = 360
    end = start

    global shoulder_left
    global shoulder_right

    shoulder_loc = ((-8.841815/1.28082)*A, (-1.016781/1.28082)*A, (1.557212/1.28082)*A)
    shoulder_rot = mathutils.Euler((math.radians(338.534), math.radians(273.483), math.radians(21.1521)), 'XYZ')

    global costa
    costa = Costa(P, A, move, part, helicity, start, end,
        shoulder_loc, shoulder_rot, shoulder_left, shoulder_right)
#        shoulder_loc, shoulder_rot, shoulder_left, shoulder_right,
#        neck_loc, neck_rot, neck)


def spine():

# scale factor
    A = 1.71652

# pivot factor
    P = (-1.656175/1.71652)*A
    
# name
    move = 'equestrianism-pace'

# element
    part = 'spine' 

# left or right
    helicity = 'left'

    start = 180
    end = start-720*2

    global costa
    global ilium_left
    global ilium_right

    costa_loc = ((-2.62224/1.71652)*A, (-0.810857/1.71652)*A, (1.28082/1.71652)*A)
    costa_rot = mathutils.Euler((math.radians(-270), math.radians(0), math.radians(315)), 'XYZ')

    ilium_loc = ((8.423421/1.71652)*A, (-14.897697/1.71652)*A, (-0.813787/1.71652)*A)
    ilium_rot = mathutils.Euler((math.radians(90), math.radians(-180), math.radians(432.166)), 'XYZ')

    global spine
    spine = Spine(P, A, move, part, helicity, start, end,
        costa_loc, costa_rot, costa, ilium_loc, ilium_rot, ilium_left, ilium_right)


def sacrum():

# scale factor
    A = 0.215914

# pivot factor
    P = 0

# name
    move = 'equestrianism-pace'

# element
    part = 'sacrum'

# left or right
    helicity = 'left'

    start = 0
    end = start+0 

    global spine

    spine_loc = ((14.937735/0.215914)*A, (-0.30611/0.215914)*A, (9.682981/0.215914)*A)
    spine_rot = mathutils.Euler((math.radians(-270), math.radians(-44.5509), math.radians(180)), 'XYZ')

    global sacrum
    sacrum = Sacrum(P, A, move, part, helicity, start, end,
        spine_loc, spine_rot, spine)

    sacrum_loc = ((6.310129/0.215914)*A, (4.989754/0.215914)*A, (10.548208/0.215914)*A)
    sacrum_rot = mathutils.Euler((math.radians(-90.0), math.radians(180.0), math.radians(0.0)), 'XYZ')

    # position
    sacrum.rig.location.x += sacrum_loc[0]
    sacrum.rig.location.y += sacrum_loc[1]
    sacrum.rig.location.z += sacrum_loc[2]

    sacrum.rig.rotation_euler = sacrum_rot


def main(origin):
    
    # create new collection
    newCol = bpy.data.collections.new('movement')
    # link the newCol to the scene
    bpy.context.scene.collection.children.link(newCol)

    newCol = bpy.data.collections.new('link')
    bpy.context.scene.collection.children.link(newCol)

    global interval
    global frame_start
    global frame_end

    frame_start = 0
    frame_end = 240

    interval = frame_end - frame_start

#    formula()

    head()
    neck()

    lowerforelimbs()
    upperforelimbs()
    shoulder()

    tail()
    
    lowerhindlimbs()
    upperhindlimbs()
    ilium()
    
    costa()
    spine()
    
    sacrum()

if __name__ == "__main__":
    # renaming of corrada objects
#    for ob in context.collection.objects:
#        if "joint_" in ob.name:
#            ob.name = ob.name.replace("_", ".")
            
    main((0.0, 0.0, 0.0))
